# NIO와 IO

우선 단어의 의미들을 잘 집고 넘어가는게 이해하기에 좋다. 단어의 정의를 내리기 위해 동기, 비동기 와 Blocking, Non-Blocking 에 대해 알아보자.

## #1. 동기/비동기, Blocking/Non-Blocking  
이해하기 쉽게 조금 더 넓은 개념인 동기와 비동기에 대해서 한번 알아보자.
제어권의 반환과 결과값의 전달 이 두가지 시점을 가지고 이야기해보겠다.    

### 동기
동기라고하면 다들 한작업이 끝나기 전까지는 다른 작업은 시작될 수 없다. 즉 한번에 하나의 작업만 수행이 가능하다는 것으로 알고있다. 하지만 알아두면 좋은 한가지는 두가지 작업이 제어권과 결과값을 동시에 반환하는 경우에도 동기라고 이야기 할 수 있다는 것이다. 

즉, 동기 == 몇개의 작업이던간에 결과값과 제어권의 반환이 같은 시점에 하나의 지점에서 일어나는 것.(결과와 제어권이 동시에 움직일 필요는 없다.)  

### 비동기
비동기는 제어권과 결과값이 서로 상관없이 작업이 진행되는 것을 의미한다. 그냥 각 작업의 결과와 상관없이 프로세스가 진행된다. 결과값을 가지고 바로 처리를 하지 않아도 된다. 
  
### Blocking
하나의 메서드 작업이 결과값을 반환하기 전까지 제어권은 해당 메서드(작업)이 가지고 있는다. 즉 하나에 하나씩만 실행이 가능하다.  

### Non-Blocking
하나의 작업을 하고 다른 작업을 수행할 수 있다. 하지만 계속해서 해당 메서드(작업)에 끝났는지 여부를 물어봐야한다.  

### 비동기 Vs Non-Blocking
여기서 비동기와의 차이는 결과값에 있다.  
- Non-Blocking의 경우 아직 끝나지 않았다는 의미의 EWOULDBLOCK 결과 값을 반환해주고 반환 결과를 계속해서 체크한다.  
- 비동기는 결과값에 상관 없이 작업을 진행시킨다.  

### 동기 Vs Blocking
대기큐에서  
- 기다리면 Blocking  
- 기다리지 않으면 동기  
  
## #2. IO의 단점을 개선한 New IO  
기존의 IO의 경우 blocking API를 사용해서 Input/Output 작업한다. 대표적으로 InputStream, OutputStream을 볼 수 있다. 이 클래스의 메서드를 사용하게 되면 작업을 진행하는 쓰레드나 프로세스는 다른 작업을 진행하지 못한채 제어권과 결과값을 기다린다. 이 말은 성능면에서 다소 느리다라는 말로 들릴 수도 있다.   
  
이러한 메서드들을 사용하는 서비스를 다수의 클라이언트가 이용한다고 해보자. 쓰레드를 독립적으로 실행시켜 사용할 수 있겠지만 쓰레드 또한 유한한 자원이다. 결국 사용자는 대기를 해야하는 상황이 발생하고 이는 서비스에 꽤나 치명적이다.  
  
이를 개선한게 자바의 JDK 1.4에서 추가된 NIO(new Input/Output)이다. 

## #3. IO vs NIO. 
  
### Stream vs Channel  
IO는 기본적으로 stream 기반의 입출력을 한다. 하지만 이 stream은 쓰기와 읽기를 위한 stream을 따로 생성해줘야한다.  
이에 반해 NIO의 경우는 Channel 기반으로 입출력을 한다. 이 Channel은 양방향으로 읽고 쓰는게 가능하다. 따라서 따로 생성할 필요가 없다.  
  
### NonBuffer vs Buffer. 
IO의 경우, 입력 Stream이 1 바이트 입력되면 출력 Stream 1바이트 씩 읽는다. 하지만 NIO의 경우에는 Buffer를 기본적으로 지원하기 때문에 Buffer를 통해 입력된 데이터를 한번에 읽어드리고 한번에 출력하는 것이 가능하다.  
  
NIO를 쓰면 이러한 버퍼 덕분에 저장되어있는 자원에서 필요한 것들을 골라쓸 수 있다. 하지만 IO의 경우에는 읽은 데이터를 별도로 저장하지 않으면 소멸된다.  

하지만 IO에서도 방법은 없는 것은 아니다. Buffer를 지원하는 BufferInputStream, BufferOutputStream과 같은 클래스를 사용할 수 있다. 
  
### Blocking과 NonBlocking. 
맨 위에서 다룬 개념이 나오는데 기존의 IO의 Blocking API를 사용하면 하나의 작업이 끝날 때까지 다음 작업은 제어권을 갖지 못했다. 하지만 NIO에서는 Non-Blocking 방식을 지원하기 때문에 다른 이전 작업이 완료될 때까지 기다릴필요가 없어졌다.(쓰레드를 Interrupt할 수 있는가 없는가의 차이)    

## #4. IO vs NIO의 선택

NIO는 불특정 다수의 클라이언트 연결 또는 멀티 파일들을 넌블로킹이나 비동기로 처리할 수 있다.
- 과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용한다는 점이 큰 장점이다. 
- 운영체제의 버퍼(다이렉트 버퍼)를 이용한 입출력이 가능하기 때문에 입출력 성능 향상
 
NIO는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우에 사용하는것이 좋다.
스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업의 수가 늘어나기 때문에 제한된 스레드로 처리하는 것이 불편할 수 있다.
 
대용량의 데이터 처리의 경우 IO가 좋다.
- 연결 클라이언트 수가 적고 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있는 경우 IO로 서버를 구현하는 것이 좋다.
NIO는 버퍼 할당 크기도 문제되고, 모든 입출력 작업에 버퍼를 무조건 사용해야 하므로 받은 즉시 처리하는 IO보다 복잡하다.  
출처: https://dev-coco.tistory.com/42 [슬기로운 개발생활😃:티스토리]




