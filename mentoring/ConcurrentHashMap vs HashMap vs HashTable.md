## #0. ConcurrentHashMap vs HashMap vs HashTable 뭐가 다른가?
우선 기본적으로 제공하는 것은 같습니다. key/value 값을 저장하고 활용할 수 있는 기능을 제공해준다.. 중요한 것은 key 값을 hashing 해서 저장하기 때문에 조회가 아주 빠르다. 
  
그럼 차이를 간략하게 알아보자. 우선 가장 중요한 키워드 syncronized를 알아야한다. 자바에는 syncronized라는 예약어가 있다. 이 예약어는 멀티쓰레딩 환경에서 각 쓰레드가 하나의 자원에 대해 접근하는 것을 막는 예약어다.(volatile이나 클래스를 Automic하게 만드는 방법(불변개게)도 있다.) 내부 멤버 변수에 이 예약어를 가지고 있느냐 없느냐에 따라서 구분된다고 생각하고 다음 글들을 보자. 
  
## #1. HashTable
syncronized를 남발하면 성능 저하가 발생한다. syncronized를가 작성되어 있는 자원/멤버를 사용하게되면 처리하는 쓰레드의 경우 Lock이 걸린다.(쓰레드가 해당 자원의 제어권을 독립적으로 가지고 있다. Blocking) 따라서 다른 쓰레드는 제어권이 자신에게 올때까지 기다려야합니다. 시간이라는 비용이 발생하기때문에 병목현상은 피하기 힘들 것이다. HashTable이 이와 같은 경우이다. HashTable이 가진 대부분의 멤버에는 동기화 예약어가 함께 작성 되어 있다. hashtable의 멤버를 사용할 때 마다 Lock 걸린다. 문제가 있다. Collection 패키지가 나오기 전까지 사용되던 객체이기 때문에 요즘은 많이 사용되지 않는다.  

## #2. HashMap
이와 반대로 HashMap의 경우는 동기화 예약어가 하나도 없다. 이 말은 쓰레드 세이프하지 않다는 말과 같다. 레이스 컨디션의 발생 가능성이 열려있다.( 멀티쓰레딩환경에서 여러개의 쓰레드들이 하나의 자원에 동시에 접근하여 데이터의 일관성을 보장하지 못하는 경우 ) 하지만 빠르다.  
  
## #2. ConcurrentHashMap
두가지의 단점을 보완해서 새로 나온 클래스가 ConcurrentHashMap이다. 이 클래스에서 HashMap과 차이가 있는 부분은 put 관련된 메서드들에서 볼 수 있다.  
<img width="727" alt="스크린샷 2022-07-04 오후 3 05 24" src="https://user-images.githubusercontent.com/78134917/177091497-b061305d-9ade-490e-84d3-5a9f414e701a.png">   

멤버 메서드에는 syncronized가 없는 것을 볼 수 있다. syncronized 블럭을 사용해서 조건적으로 동기화를 사용하고 있기 때문에 모든 행위마다 lock이 걸리지 않는다. 이러한 것들로 인해 

속도 측면에서 ConcurrentHashMap은 HashMap보다는 느리지만 쓰레드 세이프하다는 특징을 가지고 있다. 대부부분의 Concurrent* 키워드가 붙은 클래스는 이런식이다.  
  
하지만 주의해야하는 것은 언제나 ConcurrentHashMap이 옳은게 아니라는 생각을 가지고 있어야한다. 싱글 쓰레드로 동작하는데 보다빠른 HashMap을 사용하지 않고 Concurrent를 사용하는 것은 문제가 있다. 멀티쓰레딩 환경에서 발생할 경우를 대비한다는 것은 이유 없이 기술을 사용한다는 의미이기도 하기 때문이다. 
