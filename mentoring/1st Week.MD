# Data Base

## Index
### Index가 뭔가요?
Index는 '색인'이라는 뜻을 가집니다. 색인의 뜻은 아래와 같습니다.

<img src="https://user-images.githubusercontent.com/78134917/153604198-de8e2cdb-9808-4ee2-87c7-1d7ad106d3ed.png" width="700" height="200"/>

아주 두꺼운 전공서적이나 책들을 보면 맨 뒷장 언저리에 '가나다'순으로 나열된 색인을 볼 수 있습니다. 색인은 원하는 자료를 두꺼운 책에서 쉽게 찾을 수 있도록 도와줍니다. 
데이터베이스에서의 인덱스도 같은 일을 합니다. 1억 페이지가 넘는 책(=테이블)에서 원하는 자료(=데이터)를 쉽게 찾기 위해 존재하는 색인(=인덱스 테이블) 

> 데이터베이스에서 인덱스란 테이블에 대한 검색 성능(SELECT)을 향상시키기 위한 자료구조의 한가지입니다. 
<br/>
<br/>

### Index사용 이유
**원하는 데이터 조회시 불필요한 작업을 줄여 비용을 아끼기 위함** 
만약 1억건의 데이터가 있다고 치겠습니다. 이 1억건의 데이터 중 자주 사용되는 데이터들은 메모리에 올라가 조회 시 빠르게 찾아올 수 있습니다. 하지만 그렇지 않은 경우에 데이터베이스는 
이 1억건의 데이터를 모두 조회합니다. 이러한 조회 방식을 **FULL TABLE SCAN** 방식이라고 합니다. **FULL TABLE SCAN** 조회 방식을 개선하기 위해 인덱스라는 자료구조가 생겨났습니다.
실제 DB를 사용하면서 인덱스를 쓰는 이유를 살펴보자면 아래와 같습니다.
<br/>
> * WHERE 구문과 일치하는 열을 빨리 찾기 위해.
> * 특정 열을 고려 대상에서 빨리 없애 버리기 위해.
> * 조인 (join)을 실행할 때 다른 테이블에서 열을 추출하기 위해.
> * 특정하게 인덱스된 컬럼을 위한 MIN() 또는 MAX() 값을 찾기 위해.
> * 사용할 수 있는 키의 최 좌측 접두사(leftmost prefix)를 가지고 정렬 및 그룹화를 하기 위해.
> * 데이터 열을 참조하지 않는 상태로 값을 추출하기 위해서 쿼리를 최적화 하는 경우.

### 인덱스의 생성원리
B+Tree 알고리즘으로 색인화를 하고 인덱스 자료구조 형식을 가지게 됩니다. B+Tree(Balanced Tree)에 대해선 아래에 더 자세히 알아보도록합시다. 
지금은 'Binary Tree > B-tree(Balanced Tree) > B+ tree'의 순서로 확장되었으며 이로 인해 색인화 과정에서 데이터가 한쪽으로 치우치지 않고 균형있는 tree 구조로
생기도록 도와주는 알고리즘이라고 보면 좋습니다.

어떤 테이블의 하나의 컬럼을 인덱스로 지정합니다. 그렇게 되면 초기 테이블 생성시 만들어지는 MYD,MYI,FRM 3개의 파일중에서
MYI에 해당 컬럼을 색인화(인덱싱)하여 저장합니다(인덱스 테이블 생성). 그래서 SELECT문으로 조회할때 WHERE 조건문에 인덱스로 지정한 컬럼으로 조건을 주게되면 마스터 테이블을 조회하지 않고
MYI파일을 검색해 해당 ROW를 찾습니다.그렇지 않을 경우 위에서 이야기한 것과 같이 FULL SCAN을 진행하여 시간이 더 소요됩니다.

### Index의 종류
여러 종류의 Index가 있지만 주로 많이 언급되고 사용되는 Index는 Clustered Index와 Non Clustered Index 두가지 입니다.
둘의 차이는 뭘까요? 우선 cluster의 뜻을 보면 '무리'라는 뜻을 가지고 있습니다. 이렇게 생각하면 위의 두가지를 '무리지어진 인덱스'와 '무리지어지지 않은 인덱스' 정도로 해석할 수 있습니다.


* **Clustered Index** (= 사용자 지정이 아닌 MYSQL 자동지정 생성 인덱스, 정렬된)


Clustered Index는 데이터가 테이블에 물리적으로 저장 되는 순서를 정의(설정)한다. 즉, 클러스터 형 인덱스는 특정 컬럼을 기준으로 데이터들을 정렬시킨다.

1. 테이블에 AUTO INCREMENT로 생성된 PK 컬럼이 있다면 데이터베이스가 자동으로 해당 컬럼을 Clustered Index로 지정합니다.
2. pk가 없다면 Unique key를 Clustered Index로 지정합니다.
3. unique컬럼도 하나도 없다면? MySQL에서 내부적으로 Hidden Clustered Index Key (row ID)를 만들어 Clustered Index로 사용합니다.
4. 테이블 데이터는 오직 한 가지의 방법으로만 정렬되기 때문에 오직 테이블 당 하나의 클러스터 형 인덱스만 존재할 수 있다. 즉, 정렬 기준으로 오직 하나의 컬럼만을 선택할 수 있습니다.
5. Database에서 primary key의 제약조건(constraint)은 클러스터 된 인덱스를 자동으로 생성하기 때문에 우리가 일반적으로 테이블을 생성할 때 특정 컬럼에 primary key를 지정했다면, 자료가 자동으로 정렬되는 것입니다.
6. primary key를 설정하지 않은 테이블에 무작위로 데이터를 insert하고, 테이블을 조회하면 뒤죽박죽인 테이블을 보게될 것입니다.

그래서 Clustered는 왜 사용하는가?
삽입/삭제를해도 자동으로 데이터를 정렬해주기 때문이다(5번과 같음). 문제는 여기서 발생합니다. 우리가 한 배열의 중간에 값을 삽입하려고 하면 해당 위치 뒤쪽에 있는 공간들을 한칸씩 뒤로밉니다.
그리고 새로운 데이터를 삽입합니다. 삭제도 이와 마찬가지 입니다. 데이터가 적다면 문제가 안되지만 1억건이라고 했을때는 말이 달라집니다. 따라서 아래와 같은 경우에서 사용하는 것을 권장합니다.
* 테이블 데이터가 자주 업데이트 되지 않는 경우
* 항상 정렬 된 방식으로 데이터를 반환해야하는 경우
* 테이블은 정렬되어있기 때문에 ORDER BY 절을 활용해 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.읽기 작업이 월등히 많은 경우, 이때 매우 빠르다.

<img src="https://user-images.githubusercontent.com/78134917/153634902-e06d6359-61ae-46e0-beee-2da641207c51.png" width="700" height="500"/>



* **NonClustered Index** (= 사용자 지정생성 인덱스, 정렬되지 않은)
1. 테이블에 저장 된 물리적인 순서에 따라 데이터를 정렬하지 않는다. 즉, 순서대로 정렬되어 있지 않다.
2. 논 클러스터 형 인덱스는 테이블 데이터와 함께 테이블에 저장되는 것이 아니라 별도의 장소에 저장된다. 마치, 위 책에서 index 페이지를 따로 나눈것 처럼 말이다.
3. 하나의 테이블에 여러개의 논 클러스터 형 인덱스를 설정할 수 있다.

어떤 경우에 nonClustered Index 생성?
* where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자할 때
* 데이터가 자주 업데이트 될 때
* 특정 컬럼이 쿼리에서 자주사용 될 때

<img src="https://user-images.githubusercontent.com/78134917/153635772-657973eb-a5d9-495a-a8ea-f34a33f60b0a.png" width="700" height="500"/>


**두가지 인덱스의 차이 정리**
* Clustered 인덱스는 테이블당 오직 한개만 존재한다. 반면에 Non-Clustered 형은 테이블 당 여러개의 인덱스를 생성할 수 있다.
* Clustered 인덱스는 오직 테이블을 정렬한다. 그러므로 별도의 공간을 필요로하지 않는다. Non-Clustered 인덱스는 저장되는 별도의 공간(약 10%)이 필요하다.
* Clustered 인덱스는 통상적으로 데이터를 찾는데 추가적인 스텝을 거치지 않기 때문에 Non-Clustered 인덱스보다 속도가 빠르다.
* Clustered 인덱스는 데이터를 삽입할 때, 모든 테이블에 존재하는 데이터들의 순서를 유지해야하므로 많은 비용이 발생한다. Non-Clustered는 별도의 공간에 인덱스를 생성해야하기 때문에 추가작업이 필요하다.
<br/>
<br/>

## 정규화

### 정규화란?
정규화는 데이터의 중복을 방지하기 위해 만들어졌다. 하나의 테이블이 수정되면 수정된 테이블과 관계가 정의된 모든 것들에 영향을 줄 수 있게 만드는 필터링으로 보면 좋습니다.
이러한 정규화 개념에의해 최초의 RDBMS인 Oracle이 만들어 졌다. 정규화에 필요한 작업(옵션)에 따라 제1 정규,2정규 3정규화로 진행되게 되며 일반적으로 3정규화 작업까지 마친 테이블을
정규화 되었다고 이야기합니다.

> 정규화된 테이블은 중복된 데이터를 허용하지 않음으로써 데이터의 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.


<br/><br/>
만약 정규화를 하지 않았을 경우에 생기는 문제점들이 있습니다. 이를 이상현상이라 부르고 대표적으로 세가지 이상현상 있습니다.(RDBMS 소프트웨어를 쓰지 않는 상황이라고 가정하면 좋습니다.)
1. 갱신이상(수정,update시 발생)
어떤 학원에서 김철수라는 사람이 3가지 강좌를 수강하고 있습니다. 학원에서는 하나의 테이블로 학원을 관리하고있습니다. 테이블에는 강좌당 강좌정보와 김철수씨의 정보가 하나의 튜플에 모두 기록되어 있습니다. 김철수라는 사람이 이사를 가서 주소가 변경되었습니다. 튜플에서 김철수 씨를 찾아서 주소를 변경해야합니다. 500명의 학생 중에 김철수씨의 정보를 모두 변경하려면 찾기가 굉장히 힘들 뿐더러 3개를 모두 찾지 못하는 경우가 발생할지도 모릅니다. 결국 갱신(update)가 제대로 이루어지지 못하고 데이터는 신뢰성을 잃게됩니다.

> 반복된 데이터 중에 일부만 수정하면 데이터의 불일치가 발생합니다.

2. 삽입이상(신규,insert시 발생)
학원에서 강좌를 신설하려합니다. 새로운 강좌를 데이터로 기록하려면 수강생이 없음에도 불구하고 불필요한 자료까지 삽입해야합니다.
> 불필요한 정보를 함께 저장하지 않고는 어떤 정보를 신규저장하는 것이 불가능합니다.

3. 삭제이상 (삭제,delect시 발생)
학원에서 수강생이 한명인 강좌를 폐쇄하려합니다. 수강생은 해당 강좌하나만 수강하고 있습니다. 학원에서는 해당 세션을 마지막으로 강좌를 폐지했습니다. 이제 학원에 해당 강좌가 존재하지 않기 때문에 데이터를 삭제합니다. 여기서 강좌 정보 자체를 삭제하려면 수강했던 수강생의 정보도 모두 삭제해야합니다. 

> 이처럼 유용한정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능합니다.

이러한 이상현상들을 제거하기 위해서 정규화 작업을 진행합니다.


#### 1정규화
릴레이션(=테이블)에 있는 컬럼들의 각 엔티티들이 원자성을 가져야한다는 규칙을 가집니다. 

값의 원자성이 지켜지지 않는 컬럼이 존재한다면 따로 원자 도메인(해당 컬럼에 사용할 수 있는 엔티티를 정의해놓은 집합) 테이블을 생성하여 분해해야합니다. 이 제1정규화를 거친 데이터는 컬럼의 값이 원자성을 지니게됩니다. 


#### 2정규화
제 1 정규화를 마친 데이터에 한해서 **부분함수적 종속을 제거하여 완전(충분한) 함수적 종속을 만족하는 정규형입니다.(제 2정규화를 위해선 1정규화가 필수입니다.)**
|회원번호|수강과목|성적|이름|
|------|---|---|---|
|k001|필기|80|김철수|
|k002|필기|90|김정기|
|k002|실기|100|김정기|
|k001|실기|90|김철수|

테이블의 정보 중에서 하나의 컬럼 값에 의해서 다른 컬럼의 값이 정해지는 경우가 있습니다. 여기서 값을 결정하는 컬럼을 결정자, 값이 결정되는 컬럼을 종속자라고 이야기합니다.
결정자 컬럼은 대개 기본키로 많이 쓰이게 됩니다. 기본키가 두개인 경우가 생기게되는데 이를 복합키라고 부릅니다.
이제 위 테이블을 보면 회원번호와 수강과목이 모두 존재해야 성적을 찾을 수 있습니다. 여기서 회원번호와 수강과목이 복합키로써 결정자 역할을 합니다. 하지만 자세히보면 회원번호는 복합키의 부분키로서 이름의 결정자역할 또한 하게됩니다. 하나의 테이블 내부에서 결정자가 두개, 종속자가 두개가 존재합니다. 이렇게 될 경우 데이터의 중복이 발생하게 됩니다. 따라서 부분종속이 이루어지고있는 회원번호에 따른 이름은 따로 테이블을 분리하는게 제 2 정규화의 핵심입니다. 

#### 제 3정규화
1,2 정규화 작업이 끝나면 정규화가 된 테이블가 되기위한 마지막 관문인 제 3 정규화 작업이 있습니다. 제 3정규화 작업에서 하는 필터링은 이행적 종속성을 체크하는 일입니다. 
이행적 종속성이라는 것이 뭘까요? 아래 테이블을 보면서 이야기해보겠습니다.

|책번호|책이름|책가격|작가번호|작가이름|작가주소|
|------|---|---|---|---|---|
|k001|함께자라기|15000|author_001|김창준|서울|
|k002|jpa프로그래밍|25000|author_002|김영한|경기|
|k002|AWS실습|28000|author_003|김동욱|충청|
|k001|자바의정석|35000|author_004|남궁성|인천|
|k002|OS 실습|23000|author_003|김동욱|충청|

여기서 기본키는 책번호 하나이고 나머지는 책번호에 종속되어 있습니다. 하지만 잘 보게되면 작가번호는 키가 아님에도 불구하고 작가이름,작가주소의 결정자가 될 수 있습니다. 이를 이행적 종속성이라고 합니다. 키가 아닌데 종속성을 가지고 있는 것들을 테이블에서 분리시키는 것이 제 3정규화 작업업니다. 정리해서 보자면

1. 모든 key가 아닌 컬럼(non-key)은 key 컬럼(속성)에 완전히 종속 되어야 한다.
2. 모든 non-key 컬럼은 key 컬럼(속성)에만 종속 되어야 한다.
3. 그래서 key가 아닌 값에 주목해서 확인해야한다.

## 트렌잭션
### 트랜잭션이란?
트렌젝션 : 데이터베이스의 상태를 변형시키기 위해 수행하는 작업단위를 이야기한다.
<br/>![85AC3938-D929-4598-AF46-A1903A6267AC](https://user-images.githubusercontent.com/78134917/153718588-6b3d4cc1-4081-4ded-87ca-33887785abfb.jpeg)

<br/>

위처럼 논리적인 업무를 처리하기 위해선 다수의 물리적 명렁어가 필요합니다. 트랜잭션이란 하나의 논리적 업무단위를 처리하기 위해 사용되는 물리적 명렁어(데이터베이스의 상태를 변경하기 위한 명령어들)를 의미하기도 한다.

트랜잭션 논리적 업무단위를 실행하여 신뢰를 얻기 위해서는 ACID라는 것이 지켜져야합니다. 

하나의 트랜잭션(논리적 업무단위)는 **원자성(Atomicity)** 을 가져야합니다. 하나의 업무단위가 모두 실행되거나 모두 실패하거나(all or noting), 하나의 업무단위가 모두 완료되고 나면 **일관성(Consistency)** 을 유지해야합니다. 즉, 데이터베이스의 상태(데이터베이스의 내용)은 유지되어야합니다. 또한, 트랜잭션은 **격리성(Isolation)** 을 유지해야합니다. 즉, 하나의 트랜잭션이 실행되게되면 관련된 데이터에는 누구도 접근할 수 없습니다.  마지막으로 트랜잭션이 완료되고 나면(Commit,Rollback) 트랜잭션의 결과로 변경된 데이터베이스의 내용들을 **지속성(Durability)** 을 유지해야합니다.

이러한 것들을 지키기 위해 현재 개발자가 사용하고 있는 **세션을 위한 임시저장소**에서 테스트하게됩니다. 따라서 트랜잭션 완료 전에 변경된 데이터들은 다른 세션의 사용자들에게는 보여지지 않습니다. 하나의 트랜잭션을 실행하고 있는 세션에서 특정 테이블을 사용하고 있다면 해당 테이블에 대해서는 lock이 걸리게 됩니다. 이러한 특징으로 인해 트랜잭션의 고립성이 성립하게 됩니다.

``` sql
--SITUATION1
-- 세션 1
SELECT * FROM MEMBER ;
insert into member(ID,PWD) VALUES ('TEST1','ABC1234!');
insert into member(ID,PWD) VALUES ('TEST2','DCC1234!');

--세션 2
SELECT * FROM MEMBER ;
-- 여기서는 위의 세션 1에서 인서트한 값들이 조회되지 않는다.(세션에서 COMMIT을 하지 않으면
-- 임시저장소에서만 데이터가 변경된다.)

-- 세션 1
SELECT * FROM MEMBER ;
insert into member(ID,PWD) VALUES ('TEST1','ABC1234!');
insert into member(ID,PWD) VALUES ('TEST2','DCC1234!');
COMMIT; -- 이렇게 세션1에서 COMMIT 명령어를 실행하여 데이터의 변경을 확정지어주면 
-- 임시저장소와 실제 사용저장소의 데이터 값이 같아지게 됩니다.

--SITUATION 2
-- 세션 1
SELECT * FROM MEMBER ;
insert into member(ID,PWD) VALUES ('TEST1','ABC1234!');
insert into member(ID,PWD) VALUES ('TEST2','DCC1234!');

--세션 2
SELECT * FROM MEMBER ;
insert into member(ID) VALUES ('TEST3');

-- 세션 1에 물려있는 MEBER테이블의 값을 다른사용자(세션2)가 변경하려 들면 이 시점에 LOCK이 걸리게 됩니다.
-- 정확히 말하자면 세션1에서 MEMBER 레코드를 사용할때 실제 저장소의 MEMBER레코드에 LOCK을 걸게됩니다.
-- 모든 변경을 완료하고 COMMIT(확정) 또는 ROLLBACK(반려)를 명령해서 트랜잭션을 마무리하면 세션2의
-- INSERT문은 실행됩니다.

```
<br/>
<br/>
위에서 이야기한 ACID 중 격리성에 관해서 조금 더 알아보겠습니다.

### 트랜잭션의 격리 수준(Transaction Isolation Level)
<br/>

위에서 이야기했던 것 처럼 하나의 트랜잭션이 조작하고 있는 레코드를 다른 트랜잭션이 접근할 수 없는 것이 격리성이었습니다.
조금 더 자세히 보면 이 격리성은 무작정 접근을 제한하는게 아닙니다. DB에 따라 격리에 대한 접근레벨이 존재하고 격리성을 강하게 혹은 약하게 처리할 수 있습니다. 
<br/>

격리성으로 인해 발생할 수 있는 문제들은 주로 Dirty Read, Non-Repeatable Read, Phantom Read 이 세가지라고 합니다.\
이 세가지 모두 격리성이 낮을 경우에 생기는 문제점입니다.
<br/>
**1. Dirty Read = 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것을 말합니다.**
<br/>
**2. Non-Repeatable Read = 한 트랜잭션 내에서 같은 Key를 가진 Row를 두 번 읽었는데 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상**
<br/>
**3. Phantom Read = 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상**

트랜잭션은 격리 수준을 정하여 이러한 문제점들에 유연하게 대처할 수 있습니다.

**Read Uncommitted**
트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용합니다. 해당 수준에서는 Dirty Read, Non-Repeatable Read, Phantom Read가 일어날 수 있습니다. 이 설정은 정합성에 문제가 있기 때문에 권장하는 설정은 아닙니다.

**Read Committed**
트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용합니다. 따라서 Dirty Read의 발생가능성을 막습니다. 커밋 되지 않은 데이터에 대해서는 실제 DB 데이터가 아닌 Undo 로그에 있는 이전 데이터를 가져오는 것입니다. 하지만 Non-Repeatable Read와 Phanton Read에 대해서는 발생 가능성이 있습니다.

**Repeatable Read**
트랜잭션내에서 삭제, 변경에 대해서 Undo 로그에 넣어두고 앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 Undo 로그에 있는 백업데이터를 읽게 합니다. 이렇게 함으로써 트랜잭션 중 값의 변경에 대해서 일정한 값으로 처리할 수 있습니다. 이렇게하면 삭제와 수정에 대해서 트랜잭션내에서 불일치를 가져오던 Non-Reapeatable Read를 해소할 수 있습니다. Multiversion Concurrency Control

**Serializable Read**
트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않도록 하는 설정입니다.

## Database Lock
### Lock이란?
데이터베이스의 무결성(데이터의 정확성)과 일관성을 유지하기 위한 방법을 의미한다.(주체는  트랜잭션입니다.)

### Lock의 사용이유
여러 사용자가 하나의 릴레이션의 엔티티를 사용한다고 했을 때, 다수의 사용자가 동일한 컬럼의 값을 수정 혹은 조회하게 될 상황이 옵니다. A라는 사람이 새로운 값으로 업데이트를 했고 B라는 사람이 
해당 값을 조회하여 어떠한 작업을 했습니다. 하지만 A라는 사람이 잘못 업데이트한 것을 깨닫고 모든 처리를 ROLLBACK 시켰습니다. 이렇게되면 B라는 사람이 조회해간 값은 릴레이션에 실제하는 데이터와 다른 값을 사용하게 된 것입니다. 이렇게 동시성 이슈로 인해 데이터의 무결성과 트랜잭션의 일관성이 깨진 상황이 발생할 수 있습니다. 

이러한 문제를 사전에 막기 위해 Lock 이라는 기술을 사용하기 시작했습니다.

### Lock의 종류(벤더사마다 모두 다름, innodb에 맞춰진 내용)
1. 베타잠금(Exclusive Locks = x lock)
    write에 대한 lock 입니다.
    select for update, update, delete 등의 수정쿼리를 날릴 때 각 ROW에 걸리는 LOCK을 의미
    하나의 트랜잭션에 의해 X LOCK이 걸려있으면 다른 트랜잭션들은 S LOCK, X LOCK 모두 걸 수 없다.
2. 공유 자금(Shared Locks = s lock)
    read에 대한 Lock 입니다.
    S Lock이 걸린 row에는 다른 트랜잭션이 추가로 S Lock을 걸 수 있지만 X Lock은 불가능합니다.
3. 레코드 락(Record Lock)
    innoDB에서 Record lock은 row가 아닌 DB index record에 걸리는 lock을 의미합니다.
    테이블에 index가 없다면 숨겨져있는 clustered index를 사용하여 레코드 락을 실행합니다.
4. 갭 락
    index record의 gap에 걸리는 lock
    여기서 gap은 index record가 없는 부분
    조건에 해당하는 새로운 row가 추가되는 것을 방지한다.
    
### Dead Lock(교착 상태)

두개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
둘 이상의 프로세스 혹은 스레드가 한정된 자원을 얻지 못해 다음 처리를 진행하지 못하는 상태를 이야기합니다.
두개의 프로세스가 서로 점유하고 있는 레코드를 사용하려 시도 할때 발생
       
    
    
 



### 참조한 페이지
https://gwang920.github.io/database/clusterednonclustered/<br/>
https://mangkyu.tistory.com/110<br/>
https://victorydntmd.tistory.com/129<br/>
https://sabarada.tistory.com/117<br/>
# Operating System
