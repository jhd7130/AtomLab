# 2주차 과제  
  

## 목차  

1. [Process & Thread](##-1.Process-와-Thread-개념)
2. [Multi Process & Multi Thread](##-Multi-Process-&-Multi-Thread)
3. Java 메모리구조
4. Java Collection Framwork
5. Garbage Collector  
</br> 

## 1. Process 와 Thread 개념  
  
    
프로세스와 쓰레드의 개념을 알기전 program에 대해서 정의내려보도록 하자.  
**Program** : 어플리케이션을 실행하기 위해 필요한 명령어와 데이터들의 집합 --> 프로그램을 실행하기 위해 필요한 코드들의 집합(없으면 절대 실행못함)  

**Process** : 실행중에 있는 프로그램을 의미 --> 운영체제가 프로그램을 실행하기위해 하나의 프로그램을 위한 메모리공간 할당, 이 메모리 공간에 프로그램의 바이너리 코드가 올라가는 순간 부터 프로그램은 프로세스로 변신  

**Thread** : 프로세스의 자원을 가지고 실제로 작업하는 가장 작은 단위를 의미 --> 프로세스의 경우 영역으로 보고 내부에서 실제 일을 작업하는 단위를 Thread라고 부른다. 이 쓰레드가 여러개이면 멀티쓰레드라고 부른다.  

하나의 예시로 이 세개의 관계를 정의내려보자.  
메드포갈릭이라는 브랜드의 주방을 생각해보자. 매드포 갈릭에 주방이라는 하나의 공간을 스테이크를 위한 공간, 파스타를 위한 공간, 설거지를 위한 공간으로 나누고 각각의 공간에서 진행할 작업에 필요한 도구 및 재료들을 모두 준비해 놓았다.(프로그램). 그리고 각각의 공간에 사람들이 재료와 도구를 모두 준비해서 요리할 준비를 마쳤고 누군가 지시를 내리면 모든 지시를 잘 받아 음식을 바로 내놓을 수 있다.(프로세스) 립아이 스테이크 주문이 들어왔다. 조수가 립아이 소고기를 가져온다.(쓰레드) 사수가 고기를 굽는다.(쓰레드) 다 구운 고기를 접시에 플레이팅 한다.(쓰레드)  

스테이크를 위한 프로세스 안에서 각각의 작업들은 쓰레드가 된다. 하나의 언어에서 정의 내리기보단 CS의 개념 자체로 이해하는게 좋을 것 같다.  

### 1-1. Process
운영체제는 프로그램을 프로세스로 위치시킬 때 프로세스를 위한 메모리 공간을 할당한다고 했다. 그럼 이 메모리 공간은 어떻게 생겼고 왜 각각의 공간이 나눠졌을까?  
  
총 네가지의 영역으로 나눠니다. (소스코드영역, Heap영역, Stack영역, Data영역)

![image](https://user-images.githubusercontent.com/78134917/154800302-6e08186b-ed30-4e38-8142-2aa50a16ef1b.png)  
![image](https://user-images.githubusercontent.com/78134917/154800330-9b93b217-fec6-470b-821f-5cd665e43166.png)  

하나씩 간단하게 보자  
Program Code : 프로그램의 소스코드가 존재하는 공간이다. 이곳에 프로그램 코드가 올라오면 프로그램은 프로세스가 된다.  
Data : 전역 변수와 Static 변수가 저장되는 공간이다. 프로그램 시작과 동시에 할당되고 종료와 동시에 해제된다.  ]
Stack : 프로그램이 자동으로 생성하는 메모리 영역, 함수 호출시 필요한 지역변수와 매개변수를 저장해 놓는 공간이다. 함수호출이 완료되면 사라진다.  
Heap : 개발자가 조작하는 메모리, 동적할당을 위한 메모리영역이라고도 한다.  

여기서 주의해야하는 것은 stack과 heap은 같은 메모리 공간을 공유한다. stack은 아래서부터 Heap은 위에서 부터 공유하는 메모리 영역을 사용한다. 이 두 공간이 서로의 메모리 영역을 넘어서게되면 Stack overflow나 heap overflow가 발생하게된다.  

### 1-2 Thread
하나의 프로세스는 여러개의 쓰레드로 구성이 가능한다.(기본적으로 프로세스는 하나 이상의 쓰레드로 구성되어 있으며 두개 이상의 쓰레드가 있는 프로스세를 멀티 쓰레드 프로세스라한다.)  
쓰레드는 개별적으로 Stack영역을 가지며 나머지 Heap, Method 영역은 프로세스와 다른 쓰레드들과 공유한다.

이론적인 부분에서 잠시 떨어져 현실적인 부분에서 쓰레드를 설명한다면 어떻게 설명할 수 있을까? 내 생각은 트랜잭션과 비슷하게 작업단위라 생각하면 쉬울 것이라 생각했다. 멀티 쓰레딩을 한다는 것 또한 같다고 본다. 세개의 작업이 있다. 한 사람이 세개의 작업을 한 작업씩 끝낸다면 너무 좋지만 우리에겐 우선순위라는 것이 있다. A의 작업에서는 a작업이 먼저 완료되야하고 B의 작업에서의  a 작업은 A의 b라는 작업보다 먼저 완료되어야 한다고 가정하면 한 사람이 이 모든 작업을 완벽하게 끝내는 것은 불가능하다. 반면에 세가지 일을 세명의 작업자가 각각 작업한다면 어떻게될까? 작업이 번갈아 가면서 이루어진다 하더라도 A작업자는 A작업에 대한 것만 기억하고 수행하면 되기 때문에 훨씬 효율적일 것이다. 
![image](https://user-images.githubusercontent.com/78134917/154801285-4a062033-ba9c-46ad-bce2-98354fae2025.png)  

프로세스와 같이 실행, 대기, 준비 상태를 가진다. 실행 상태가 변할때 마다 **Context Switching(문맥교환)** 을 실행한다.  
위 그림처럼 쓰레드는 각 쓰레드마다 register와 Stack의 영역을 가지는 이유는 뭘까?  

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 가능하게 한다.
따라서 독립적인 실행 흐름을 위한 최소 조건으로 독립된 스택을 할당한다.  

PC 값은 쓰레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.  
쓰레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.  

단, 여러개의 쓰레드가 존재한다고 해서 하나의 cpu를 가진 컴퓨터에서 여러개의 쓰레드를 동시에(한번에) CPU에 할당할 수 없다. 그렇다면 여러개의 쓰레드는 어떻게 작동될까?  
우선, 프로세스가 생성되면서 메인 쓰레드가 하나 생성되고 나머지 쓰레드는 그 이후에 생겨난다. 추가로 쓰레드를 생성하지 않으면 메인 쓰레드에서 모든 작업들이 실행된다.  


## Multi Process & Multi Thread
멀티 쓰레드의 기본적인 개념 같은 경우에는 위의 글과 같이 하나의 프로세스 안에 여러개의 쓰레드가 존재하는 것을 의미합니다. 멀티 쓰레드는 멀티 프로세스의 비효율적인 면을 개선해 줌으로 우선 멀티 프로세스의 개념과 단점을 먼저 살펴보겟습니다.  

멀티 프로세스의 경우 우리가 컴퓨터에 여러개의 프로그램을 띄워놓는 것과 같다. 여러개의 프로그램이 동시에 실행되고 있는 것 처럼 보이지만 각 프로세스에서 사용자가 사용한 기능만 실행되고 대기 상태로 돌아가게된다.  

여기서 프로세스를 여러개 띄워놓고 하나의 프로세스에서 다른 프로세스로 전환하게 되면 context switching이라는 작업이 실행되게 된다.  


## Java 메모리구조 
이제부터 JVM메모리 구조를 공부해보자.  

우선 JVM의 메모리구조를 공부해야하는 이유에 대해 먼저 생각 해보면 컴퓨터는 메모리에 존재하는 프로그램(소스코드,데이터)을 프로세스에 올리고 사용자가 사용할 수 있게된다. 결국 메모리의 데이터를 어떻게 효율적이고 정확하게 읽어올 수 있느냐는 성능에 영향을 주게된다.  

이제 JVM 메모리 구조를 보기 전에 JVM의 구조를 살펴보자.  

JVM은 크게 4가지 영역으로 나누어진다. Garbage Collector, Class Loader, Runtime Data Area, Execution Engine 이다. 하나씩 간단하게 집고 넘어가자  

**① Garbage Collector**
개발자가 작성한 객체 생성코드를 읽을 때마다 Runtime Data Area 내부의 힙영역에 해당 객체의 데이터가 적재된다. 시간에 따라 일회성으로 사용되고 더이상 사용하지 않는 객체들이 생겨나게 된다. 과거에는 객체들의 메모리 공간을 지정해주고 해제해주는 작업까지 개발자가 직접 코드로 작성해줘야했다. 하지만 JAVA에서는 이러한 수고를 덜 수 있도록 Garbage Collection을 제공한다. Heap영역에 적재되어 있는 객체 중 사용하지 않는 (Unreachable)한 객체들을 자동으로 삭제시켜준다. 시기에 맞게 작동함으로 개발자가 직접 손대지 않는 것이 좋다. 괜히 작동 시켰다가 비용(시간)이 발생할 수 있다.  

**② Class Loader**
개발자가 작성한 .java 파일은 javac(자바 컴파일러)에 의해 .class(바이트 코드)로 컴파일 됩니다. 그리고 이 컴파일된 파일을 개발자가 실행 시키면 ClassLoader가 .class 파일을 RuntimeArea Method Area에 적재한다.  

**③ Execution Engine**
Runtime Data Area에 적재된 .class 파일들을 하나의 명령단위로 읽어내린 뒤 컴퓨터가 실행할 수 있는 기계어로 번역하여 명령을 작동시킨다. JVM은 성능의 향상을 위해 작동의 방식을 Interpretor(통역사) 방식과 JIT(번역본) 방식 두가지를 사용한다.(기존에는 한줄씩 읽어내리는 Interpretor방식만 사용하여 시간이 오래걸렸다.)  

**④ Runtime Data Area**
JVM메모리 영역으로 OS로부터 별도로 메모리 공간을 할당받고 JAVA 어플리케이션을 실행할 때 사용된다. Method Area, Heap Area, Stack Area, PC register, Native Method Stack 총 5가지로 구분된다.  

### Runtime Data Area  

![image](https://user-images.githubusercontent.com/78134917/154840710-e29e0fb6-4411-4f17-b290-e3626df0bfb5.png)  
  
1. Method Area
Class Loading을 통해 바이트코드가 올라오는 영역, java 어플리케이션이 실행되면 클래스 별로 클래스에서 필요한 패키지 클래스, 런타임 상수풀, 인터페이스, 상수, static변수, final 변수, 클래스 멤버 변수 등 필드데이터, 생성자를 포함한 모든 메서드 정보 등을 로드된다. 이 메모리영역의 데이터들을 지속적으로 상주하고 있다.(클래스파일을 실행 시키기 위한 정보들의 총 집합)   

2. Heap Area  
메서드 내부에서 생성되는 객체들을 위한 영역,  new를 통해 생성된 객체, 배열, immutal 객체 등의 값이 저장된다. 이 영역은 모든 쓰레가 공유하기때문에 Heap Area에 존재하는 객체들은 모든 쓰레드에서 참조하여 사용이 가능하다.  

3. Stack Area  
Stack Area은 스레드마다 하나씩 존재하며 쓰레드가 시작될 때 할당된다. 내부에는 매소드에서 직접 사용할 지역 변수, 파라미터, 리턴 값, 참조 변수일 경우 주소 값 들이 저장된다. 만약 프로그램에서 매소드가 호출되면 매소드와 매소드 정보는 아래서 위로 Stack에 쌓이면서(PUSH) 내부 과정을 실행한다. 매소드 호출이 종료되면 해당 매소드는 Stack Area에서 제거(POP) 한다.  

4. PC register  
현재 실행되고 있는 메서드의 위치 정보를 해당 명령어를 저장해두는 공간. 멀티 쓰레딩 방식에서 대기 후 재실행이 가능한 이유이기도 하다.  

6. Native Area  
java이외의 다른 언어의 메서드가 저장되는 공간  

### Heapd의 메모리 구조(효율적인 GC의 관리를 위한)
다른 메모리 영역들과 드리게 Heap의 영역은 조금 다르다. Heap은 동적으로 생성되는 객체를 다루기 때문에 생성되는 객체의 크기를 가늠하기가 어렵다. 따라서 지속적인 관리가 필요한데 이를 GC가 자동으로 관리해준다. 이렇게 일종의 메모리 관리 프로그램인 GC를 효율적으로 관리하기 위해 Heap영역을 크게는 2가지 카테고리와 세세하게는 5가지 영역으로 나누었다.Young Generation, Old Generation 그리고 Eden과 두개의 Survior(1,2), Old, Permenent(생성된 객체의 주소가 저장되는 영역이다). 나눈 이유에 대해선 GC의 작동 방식을 이해하면 납득 될 것이다.   

![image](https://user-images.githubusercontent.com/78134917/154841693-d48f5efa-75e1-4d8c-aee9-55167f6f969e.png)  


새로운 객체가 생성되면 객체의 데이터가 Heap의 Eden영역에 할당(Allocation)된다. Eden 영역이 가득 차면 MinorGC가 발생하게되고 더 이상 사용되지 않는 객체는 메모리를 해제하고 지속적으로 사용중인 객체는 Survivor1영역으로 옮겨지게 된다. 다시 Eden영역이 가득차서 MinorGC가 발생하면 Eden의 생존 객체가 Survivor2영역에 옮겨지게되고 데이터가 존재하는 Survivor1영역의 생존한 객체들도 Survivor2로 이동하게된다(Eden이 가득찰 때마다 survivor1과2를 번갈아가면서 이동한다). 이 작업이 반복되다가 오래살아 남은 객체는 Old 영역으로 promotion되게 되는데 이의 기준을 age로 잡게된다. Eden에서 survivor로 옮겨가게되면 age가 올라가게되고 survivor1에서 survivor로 이동하면 다시 age가 올라가게된다. age의 수준을 정해 놓으면 해당 age에 도달했을 때 promotion이 이루어지게 된다.  

promotion의 지속적인 발생으로 old영역의 메모리 공간이 가득차게되면 MajorGC(Full GC)가 발생하게된다. 이 MajorGC의 경우는 시간이 오래 걸린다.  

Garbage Collection(Full GC의 종류이다.) 같은 경우 여러가지 종류가 존재한다.   

1. Parallel Collector (Throughput Collector)  일
mark-sweep-compact 알고리즘을 사용한다  
Full GC와 Minor GC의 작동을 병렬식으로 처리한다.
> mark : Old 영역에 살아 있는 객체를 식별하여 표시해 놓는다  
> sweep : heap의 앞부분 부터 확인하여 살아있는 객체만 남긴다  
> compact : 각 객체들이 연속되게 쌓이도록 가장 앞 부분부터 채워서 객제가 존재하는 부분과 없는 부분으로 나눈다  
Parallel GC는 GC를 처리하는 쓰레드가 여러 개다.  
메모리가 충분하고 코어의 개수가 많을 때 적합한 GC 방식이다. 

2. CMS GC(Concurrent Mark-Sweep Collector)  
STW의 시간이 짧지만 GPU의 리소스를 많이 사용한다. Compactation이 없어서 메모리의 파편화 때문에 다른 방식보다 STW의 시간이 오래걸린다.  
Young 영역은 병렬 처리, CMS 콜렉터 방식은 2개 이상의 프로세서를 사용하는 서버에 적당하다. 가장 적당한 대상으로는 웹서버가 있다.
![image](https://user-images.githubusercontent.com/78134917/154844385-980058ae-22e5-49e4-8329-0ef334f7d76d.png)  
> Initial Mark 단계 : class loader에서 가장 가까운 객체 중 살아 있는 객체만 찾는다 (mark)  
> Concurrent Mark 단계 : 올스탑(stop-the-world)없이 살아있다고 확인한 객체에서 참조하고 있는 객체를 확인한다  
> Remark 단계 : Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인한다  
> Concurrent Sweep 단계 : 올스탑(stop-the-world)없이 참조 되지 않는 객체를 정리한다  


3. G1 GC(Garbage First)  -- GC 중 가장 빠르다
CPU리소스 및 메모리 파편화의 단점을 해결하기 위해 만들어진 방식이며 Promotion의 단계가 사라진 GC이다.    
바둑판 형식의 메모리 구조를 이용하며 바둑판의 구역하나가 다 차면 다른영역에 데이터가 적재된다.
![image](https://user-images.githubusercontent.com/78134917/154844727-42c431b8-9ef0-4e5f-a8b6-36387d4ac20f.png)  




