# 2절. 웹프로그래밍 기초 다지기.

웹 어플리케이션은 웹 기반의 구동입니다. 따라서 웹 브라우저와 웹 서버간의 통신 프로토콜을 이해하는 것이 필수입니다.  이 프로토콜을 HTTP(Hyper-Text Transfer Protocol)이라고 부릅니다. 

### HTTP 프로토콜 이해하기

**HTTP프로토콜** : 웹 브라우저와 웹 서버 사이의 데이터 통신 규칙


![Untitled](https://user-images.githubusercontent.com/78134917/174471723-05062b44-85ce-4c65-ab6e-8db152e69f4b.png)


우리가 url을 클릭하거나 주소창에 주소를 입력하면 웹 브라우저는 해당 정보를 HTTP 요청 형식에 따라  웹 서버에 전달합니다. 웹 서버는 요청 형식을 받아 해당 요청을 수행한 뒤 HTTP 응답 형식에 맞춰진 데이터를 보냅니다.

현재의 프로토콜은 단순히 정보 전달,파일 전송 뿐 아니라 원격 컴퓨터에 있는 함수나 객체의 메서드를 호출할 때도 사용됩니다. 이러한  HTTP 프로토콜을 응용한 기술로 많이 언급되는 것들이 SOAP(Simple Object Access Protocol)과 RESTful(Representational State Transfer)입니다. 또한 협업을 도와주는 기술인 WebDAV(world wide web distributed authoring and versioning) 과 이를 응용하여 캘린더 데이터를 보다 쉽게 편집할 수 있는 CalDAV기술도 있습니다. 

### HTTP 모니터링

웹 브라우저와 웹서버 사이에 오가는 정보를 보려면 HTTP 프록시 프로그램(서버 )이 필요합니다. 이 프로그램을 설치하게되면 프록시가 둘 사이에서 요청과 응답에 대한 중계인 역할을 해주게됩니다. 따라서 둘 사이에 오가는 내용을 볼 수 있습니다.

- 여기서 잠깐
프록시 서버는 중계소의 역할을 하는데 왜 사용할까요?  1. 빠른 전송을 위해 캐시에 서버의 응답 결과를 저장해 두는 것입니다. 2. 프록시에서 외부로 전달되는 데이터를 검사하여 송수신 차단등 조치를 취하여 보안에 유리하다.
cache : 외부 서버로 부터 받은 데이터를 임시 보관해두는 장소
- 프록시(proxy)는 대리의 의미를 가지고 있다. 중간자의 역할

### HTTP 요청&응답 메세지
![Untitled 1](https://user-images.githubusercontent.com/78134917/174471743-4a660648-a3cb-4069-bac3-d52b4535b567.png)


## 요청 메세지

![Untitled 2](https://user-images.githubusercontent.com/78134917/174471754-70202052-f8f3-448c-aa21-eb466a7579df.png)

프록시 서버를 모니터링 할 수 있는 프로그램이 있습니다. 'Charles' 라는 프로그램을 사용하여 http프로토콜의 요청 형식과 응답 형식을  RAW 레벨로 확인이 가능합니다. 

웹브라우저에서 HTTP 요청을 보내는 것 부터가 웹 프로그래밍의 시작이기 때문에 먼저 HTTP요청을 확인하겠습니다.

메세지들을 보기 전에 알아둘 것이 있습니다.

웹브라우저는 요청 데이터의 라인을 구분하기 위해 문자열(한문장)끝에 개행 문자를 붙여 웹 서버에게 전달합니다. MS윈도우는 CR과LF를 사용하고 OSX등의  UNIX 계열에서는 LF코드만을 사용하여 완전한 호환이 되지는 않습니다.

요청 메세지의 구성은 아래와 같습니다.

1번 라인 : 요청 라인(REQUEST LINE)

2~7번 라인 : 요청 헤더

8번 라인  : 공백(요청메세지와 넘어오는 본문을 구별하기 위함) 

그 아래 라인 : 본문

![Untitled 3](https://user-images.githubusercontent.com/78134917/174471771-1ae057d6-dcf2-4c63-bb52-2097e852a0e4.png)

**요청 라인(Request line)**

위와 같이 **공백** / **공백 HTTP**/**1.1 같은 형식으로 이루어 져있습니다.**

> **GET / HTTP/1.1**
> 

맨 앞의 메서드는 대표적으로 GET, POST 방식이 있지만 HEAD, PUT, DELETE, TRACE, CONNECT, OPTIONS등도 있습니다. 그 뒤에 / 는 요청 URL 입니다. 본문이 있는 가상의 경로를 나타냅니다. 마지막으로 HTTP/1.1은 웹브라우저에서 작성된 요청 정보가 어떤 버전의 프로토콜로 작성되었는지 명시하기 위함입니다.(그래야 웹서버가 읽을때도 오류를 줄일 수 있습니다.)

**요청 헤더(HEADER)**

웹 서버가 요청을 처리할 때 참고하라고 클리이언트 서버에서 알려주는 정보입니다.

만약 o가 있다면 영인지 알파벳 오 인지 알수없습니다. 컴퓨터는 헤더 정보를 바탕으로 구별합니다. 

> USER-AGENT : Mozilla/5.0(Macin..
> 

헤더 이름과 헤더 값으로 이루어져있습니다.
헤더는 네가지 종류가 있습니다. 1. 일반헤더(요청/응답) 2.요청헤더 3. 응답헤더 4.인티티헤더(본문 설명)

**공백 라인**

8번 라인인 공백라인은 요청 헤더의 끝을 표시합니다. 요청은 본문의 내용이 없이 URL에 정보를 모두 붙여 보냅니다.(그래서 GET방식의 요청은 내용을 URL창에서 확인이 가능합니다.) 하지만 나중에 볼 POST방식은 보낼데이터가 공백 다음에 MESSAGE-BODY로 오게 됩니다.

## 응답 메세지(Charles에서 Response 클릭)

**상태라인(status-line) : 응답결과에 대한 상태정보**

> HTTP/1.1  200  OK
> 

버전, 공백, 상태코드,공백,상태설명

**응답헤더** 

2~14번 라인에 해당합니다. 웹 브라우저가 응답 데이터를 처리할때 사용하라고 알려주는 정보입니다. 특히 안에 CONTENT-TYPE 헤더는 데이터 형식을 나타냅니다. 웹 브라우저는 이 정보를 보고 데이터를 출력할지 다운로드 창을 띄울지 등을 결정합니다. 

**공백라인과 응답 데이터**

15번은 공백라인 헤더의 끝을 표시해줍니다. 그 뒤 16번 라인 부터는 요청 메세지를 출력합니다.

이렇게 형식과 구조만 안다면 우리는 자바를 가지고 HTTP 클라이언트를 만들 수 있습니다.

코드를 보기전 순서를 한번 보겠습니다. 

①웹 서버의 기본 포트번호는 80이기 때문에 접속할 서버의 포트번호를 80으로 지정합니다. 그리고 소캣으로 입출력을 하기위한 객체를 준비합니다.

②먼저 서버에게 수행할 작업을 알려주는 요청 라인을 보냅니다. 요청 혁식은 GET방식, 원하는 자원은 웹 서버 루트 폴더에 있는 기본문서(/), 사용할 프로토콜은 HTTP1.1버전 입니다.

③웹 서버에 부가 정보를 보냅니다. HOST, USER-AGENT 등 . 접속하려는 웹 서버는 [WWW.DAUM.NET](http://www.DAUM.NET) 요청자의 정보는 크롬 브라우저.

④요청의 끝을 표시하기 위해 공백라인을 보냅니다.

⑤서버로 부터 받은 데이터를 라인 단위로 읽어서 출력합니다.(.readLine())

## GET 요청

**특징**

1. URL에 데이터를 포함 → 데이터 조회에 적합
2. 바이너리 및 대용량 데이터 전송 불가
3. 요청 라인과 헤드 필드의 최대크기
＊HTTP 사양에는 제한사항 없음
＊대용량 URL로 인한 문제 발생 하기 때문에→ 웹 서버에 따라 최대 크기 제한

**GET 요청 방식(3가지)**

1. 웹브라우저 주소창에 URL을 입력하는 경우
2. 링크를 클릭하는 경우(<a>태그 같은 경우 get요청을 만듭니다.)
3. 입력 폼에 method를 get으로 지정한 경우(기본값이 get이다)

**GET 요청의 데이터 전달 형식**

URI에 보낼 데이터를 붙입니다. HTTP 요청 정보를 확인해보면 서비스 주소 뒤에 입력 값이 붙여져있습니다.

'?'문자는 서비스 주소와 데이터를 구별하는 구분자이며 '&'문자는 데이터들을 구별하는 구분자, '=' 문자는 매개변수 이름과 값을 구별하는 구분자입니다.

GET 요청은  데이터를 조회하는 경우에 적합합니다. 검색 서비스에 GET요청을 사용하는 이유는 결과화면을 다른 사람과 쉽게 공유할 수 있기 때문입니다.

**문제점**

1. 웹브라우저 주소창에 입력한 정보가 그대로 노출 됨으로 로그인이나 개인정보 관리와 같은 보안을 요구하는 경우에는 GET요청을 사용하지 않는게 좋습니다.
2. 동영상이나 이미지 같이 바이너리 데이터를 URL에 붙여서 보낼 수 없습니다. BASE64라는 인코딩을 이용해서 가능하지만 헤더 정보가 너무 크면 웹서버에서 처리할 수가 없습니다. 
    
    ※  HTTP 사양에서는 요청라인이나 헤더 필드의 최대 크기를 제한하지 않습니다. 하지만 대부분의 웹 서버는 대용량 URL을 사용할 때 발생할 수 있는 보안 문제 때문에 최대 크기를 제한하고 있습니다.(아파치 8KB)
    

## POST 요청

특징

1. URL에 데이터가 포함되지 않는다. → 외부노출 방지
2. 메세지 본문에 데이터 포함 →실행 결과 공유 불가
3. 바이너리 및 대용량 데이터 전송 가능

GET요청의 문제점을 살짝 보안할 수 있는 또 다른 전송 방식이 POST 방식 입니다.
위의 특징에서 말했듯이 GET 요청과는 다르게 URL에 데이터가 포함되지 않아서 보안에서 강점을 보입니다. 

`<form action= "LoginServlet" method ="post">`

HTML의 입력 폼에서 method 속성을 post 방식으로 지정하면 post방식으로 넘어가게 되어있습니다.

URL 주소창에 주소를 입력하고 엔터를 누르면 GET방식과는 다르게 데이터값이 주소창으로 넘어 오지 않습니다. 그렇다면 어떻게 정보를 보낼 수 있는 걸까요?

우리는 해당 정보를 보기 위해 HTTP프록시 프로그램을 사용하여 POST 요청의 HTTP 프로토콜(요청 형식)을 살펴 볼 수 있습니다.

여기서 GET 형식과의 차이가 있는 부분은 세부분이 있습니다. CONTENTS-TYPE, CONTENTS-LENGTH, MESSAGE-BODY입니다.

보내는 데이터가 존재하는 POST 방식은 Content-Length와 Content-Type이 존재하고 Content를 포함하고 있는 message-body 영역이 있습니다.

`Content-Length :  22
Content-Type : application/x-www-form-urlencoded`

보내는 데이터 , GET 요청 방식에서 URL에 함께 보냈던 보내는 데이터는 POST 방식에서는 15번 공백라인 다음에 message-body에 포함 됩니다.

## 문제점과 개선방안

### 단점

하지만 이렇게 보안이 강화되어 단점이 된 부분도 있습니다. 요청결과를 보낸이와 받은이 두부류만 식별 가능합니다. 따라서 즐겨찾기나 메일로 공유가 불가능합니다.

### 문제점

 GET메서드와 동일하게 POST메서드 또한 데이터를 전달할 때 '이름=값&이름=값'으로 전송되는데 문자데이터를 보낼 경우에는 문제가 없지만 이미지나 동영상 같이 바이너리코드로 데이터를 전송해야하는 경우 문제가 발생할 수 있습니다. 이유는 바이너리 데이터안에 '='이나 '&'의 문자 코드를 포함할 수 있기 때문입니다. 서버는 '&' 문자로 매개변수로 구분하고, '='문자로 KEY와 VALUE를 구분하기 때문에 만약 이미지 데이터에 이런 문자 코드 값을 포함하고 있다면 잘못 해석될 수 있습니다.

### 개선방안

위와 같은 문제의 해결을 위해 바이너리 데이터를 보낼 때는 특별한 형식으로 작성하여 보냅니다.(당연히 서버에서도 형식에 맞춰 데이터를 분리합니다.)

**파일 업로드**

웹브라우저에서 웹서버에 바이너리 데이터를 보내도록 고안된 멀티파트 인코딩 방법을 확인해 보겠습니다.(multipart/form-data)

**`<form action="FileUploadServlet" method = "post" enctype="multipart/form-data">
<input type="file" name="photo">`**

우리가 일반적으로 알고 있던 get/post 형식과는 다르게 enctype(default 속성 : application/x-www-form-urlencoded)이라는 것이 붙었고 input의 type이 file로 변경되었습니다. 

### HTTP 프로토콜 분석

다시 프록시를 이용해서 확인해 보면 기존의 POST 방식과는 차이가 있다는 것을 볼 수 있습니다. 
전체 코드를 보기보다는 차이가 있는 부분만 본다면 CONTENT-TYPE과 message-body 안의 데이터 값이 변경되었습니다.

기존
Content-Type : application/x-www-form-urlencoded

 

멀티파트
Contet-Type : multipart/form-data; boundary= - - - Web .... Pyz

엔티티헤더 : 미디어 타입 ; 파트 구분자

우리는 post에서 헤더에 데이터를 담아 보낼 때 문제가 되는 상황을 발견했고 그에 대한 해결책으로 멀티 파트 전송방식을 알아봤습니다. 그렇다면 어떻게 된 것일까요?

위에서 말했듯이 바이너리 데이터는 '&' 문자를 문자 자체로 인식하기 때문에 문제가 생겼습니다. 그렇게 되면 이제 매개변수를 구분할 것도 매개변수에서 이름과 값을 이어줄 어떠한 매개도 존재하지 않게됩니다. 그래서 멀티 파트 전송 방식에서는 Content-type의 **boundary**로 시작하는 파트 구분자를 지어 줌으로써 매개변수와 값들을 구분할 수 있게됩니다.

이렇게 파트 구분자 다음 라인을 보면 매개변수 정보가 옵니다. 만약 매개변수 데이터가 파일인 경우 첨부파일의 이름과 콘텐츠 유형 정보가 추가로 옵니다. 

`name="photo"; filename="DSC00863.JPG"`
