# 5절 MVC 아키텍처

지금까지 우리는 서블릿(java 파일) 하나를 가지고 뷰 부터 데이터베이스와의 연결등 많은 것들을 한부분에서 처리했습니다. 이제는 구역을 나눠서 각각 구역이 가지는 역할을 제공하는 것에 대해 알아 보겠습니다. 

View , 즉 사용자에게 보여지는 브라우저 화면에 프린트할 것들을 PrintWriter 객체를 가지고 웹 브라우저 화면에 그렸습니다. 하지만 이 작업은 손이 많이 가기도하며 오타가 날 경우 큰 일이 벌어지게 됩니다. 그래서 먼저 할 것은 jsp파일을 사용하여 브라우저에 보여지는 VIEW 부분을 분리 시키는 기술을 배울 것입니다.

 다양한 업무 시스템에서 적용되고 검증되어 좋은 방법이라고 증명되면, 우리는 이것을 ‘최선의 관행(best practice)’라고 부릅니다. 이번 장에서는 실무 웹 어플리케이션의 최선의 관행이라고 불리는 MVC 아키텍처에 대해서 배우겠습니다.

## 5.1 MVC 이해하기


![5A845D0A-8157-4F41-B0A5-CD81B41E373A](https://user-images.githubusercontent.com/78134917/176820925-782473d4-83b8-4618-bb31-cb1da6d4d381.jpeg)


MVC의 구성 : 모델(model) ,뷰(view), 컨트롤러(controller)

Mvc모델의 필요성 : 시스템 변경이 잦은 상황에서 유지 보수를 하려면 중복되는 코드를 최소화해야합니다. 따라서 객체지향의 특성을 활용하여 역할을 세분화하고 역할 간 의존성을 최소화하면 변화무쌍한 업무 환경에 더 쉽게 대응할 수 있을 것 이기에 MVC 아키텍처(구조)는 필요합니다.



**컨트롤러 컴포넌트** 

클라이언트가 보낸 데이터가 있다면 모델을 호출할때 전달하기 쉽게 데이터를 적절히 가공하는 일을 합니다. 클라이언트 요청에 따라 모델과 뷰를 결정하여 데이터를 전달하는 일을 합니다.

**모델 컴포넌트**

데이터 저장소와의 연동을 담당하며 사용자가 입력한 데이터나 사용자에게 보여줄 데이터를 다루는 일을 담당합니다.

**뷰 컴포넌트**

사용자에게 데이터를 보여주는 일을 담당합니다.

### MVC의 이점

- **높은 재사용성, 넓은 융통성**
1. 룩앤필을 쉽게 교체 가능 : 뷰를 컨트롤러, 모델과 분리했기 때문에 뷰를 변경해야할 때는 뷰만 변경하면 모든 걸 재사용할 수 있다. 
2. 원 소스 멀티유즈 : 모델 컴포넌트가 작업한 결과를 여러가지 뷰 컴포넌트에 보여주는게 가능   합니다. 
3. 코드의 재사용성이 높아집니다.
- **저렴한 비용으로 빠른 개발**
1. 뷰 컴포넌트는 프론트앤드 개발자가, 백앤드 개발자는 컨트롤러와 모델에 전념할 수 있다.
2. 컴포넌트의 소스코드 난이도에 따라서 개발자를 고용하여 전체적인 개발 유지보수 비용을 나출 수 있다.

### MVC 구동 원리

![66D6965D-C0E7-453E-8EA9-B6723B24C727](https://user-images.githubusercontent.com/78134917/176821033-306a752b-59da-4ae4-b367-49227c4d6b20.jpeg)

### 뷰 컴포넌트와 JSP

뷰 컴포넌트는 웹 브라우저가 출력할 화면을 만드는 일을 한다면 JSP는 화면 생성을 쉽게 도와주는 기술입니다.

JSP는 출력할 코드를 단순화 시켜주는 역할을 담당합니다.(자바로 출력을 하게 되면 PrintWriter 객체를 사용하여 PrintWriter.println("출력 코드")를 매줄마다 작성해줘야 했습니다.

웹브라우저에서 요청이 들어오게되면 해당 jsp를 실행합니다. jsp를 실행하기 위해서 servlet container는 jsp파일에 대응하는 서블릿을 찾습니다. 만약 서블릿이 존재하지 않는다면 jsp엔진이 직접 자바 서블릿(자바소스)을 생성하고 자바 컴파일러가 해당 서블릿 자바소스를 서블릿 클래스 파일로 컴파일하여 구동시킵니다. 해당 jsp는 서블릿 구동 방식에 따라 실행되며 서블릿이 구동되면 jsp엔진에 의해 jsp 파일 자체가 서블릿의 service()메서드 안에서 출력문에 삽입되게됩니다. 따라서 jsp엔진 덕분에 개발자들은 따로 프린트문을 작성할 필요가 전혀 없습니다.

서블릿 없이 jsp가 구동되는 것을 보려면 자바 서블릿을 생성하지 말고 주소창에 *.jsp를 입력합니다. 그리고 톰캣 서버를 찾고 파일 안에 *.jsp와 이름이 같은 자바 클래스가 생긴 것을 확인할 수 있습니다.( 경로 : .metadata/.plugins/org.eclipse.wst.server.core/tmp0)

다시한번 강조하자면 jsp파일이 직접 실행되는 것이아니라 서블릿 안에 jsp파일이 입력되고 서블릿이 구동되는 것입니다.(중요)

### HttpJspPage 인터페이스

jsp엔진이 jsp파일 구동을 위해 서블릿을 생성할때는 HttpJspPage를 구현한 클래스를 생성합니다. 이 HttpJspPage는 Servlet인터페이스를 상속받은 JspPage를 파일을 구현한 인터페이스입니다. 이 말은 즉 HttpJspPage를 구현한 클래스 또한 서블릿이라는 의미를 지닙니다. 따라서 내부의 메서드를 보게되면 jspInit(), jspDestroy(), _jspService()로 구성되어 있습니다.

### JSP의 실체

이제는 JSP에 대해서 조금은 더 자세히 봐보겠습니다. 서블릿을 만들지 않고 JSP파일 자체를 실행시킵니다. 예를 들어 HELLO.jsp를 실행시키면 톰캣 서버 한정으로 JSP엔진이 HELLO_JSP.java파일 과 .class 파일을 생성하게 됩니다. 이 클래스파일을 자세히 보면 HttpJspBase를 상속 받고 있습니다. 

이 HttpJspBase클래스는 HttpJspPage를 구현했고(implements) HttpJspPage는 HttpServlet클래스를 상속받았습니다. 따라서 매개변수도 HttpServletRequest와 HttpServletResponse로 사용합니다. 다만 HttpJspBase(톰캣에서 제공하는 클래스) 클래스의 매개 변수는 반드시 reqeust와 response로 해야만 합니다. 또 기억해야할 것은 _jspService()의 로컬영역 변수들 중에서 아래의 참조변수들은 경로가 모두 존재해야합니다.

- final javax.servlet.jsp.PageContext pageContext;
- javax.servlet.http.HttpSession session = null;
- final javax.servlet.ServletContext application;
- jinal javax.servlet.ServletConfig config;
- javax.servlet.jsp.JspWriter out =null;
- final java.lang.Object page =this;

이걸들을 JSP 내장객체라고 부릅니다. 이 내장 객체들의 경우에는 _jspService(){ } 내부 맨앞에 선언되기 때문에 jsp파일 내부에서 jsp전용태그와 함께 어디서든 사용이 가능합니다. 

pageContext, session, application, config, out, page

### JSP프리컴파일

모든 JSP파일에 대해 서블릿클래스를 생성해 놓는 것을 의미합니다. 서블릿 클래스를 생성한다는 것은 해당 서블릿과 JSP파일에 대한 컴파일을 모두 마쳤다는 의미합니다. 그렇다는 것은 변경이 불가능하다는 의미도 내포하고 있다.  따라서 프리컴파일의 과정은 모든 웹이 안정화에 들어간 다음에 고려해 볼만한 요소이지 개발이 한창 진행 중인 웹 어플리케이션에는 맞지 않습니다.

### JSP의 주요 구성 요소

JSP를 구성하는 요소는 **텀플릿 데이터(jsp파일에서의 HTML)**와 **JSP전용태그**이다.

템플릿 데이터는  jsp파일 그자체를 이야기한다.(전용태그를 제외한) —> 후에 출력문 안으로 들어감

### 전용태그

- 지시자 : <%@ 지시자 ....%>  ——> <%@ 지시자 속성="값" 속성="값" .... %>

**page 지시자** : jsp 페이지와 관련된 속성 정의

**language 속성** : JSP페이지에 삽입되는 스크립팅 언어 지정, JAVA문자열은 모두 소문자로(대소문자인식), 디폴트 값은 JAVA이므로 생략 가능

**contentType 속성** : text/html은 출력할 데이터가 html데이터임을 지칭, charset=UTF-8 은 출력할 데이터를 UTF-8로 변환한다는 뜻

**pageEncoding 속성** : 출력할 데이터 문자집합 지정, 기본속성 iso-8859-1(영어임), 생략하면 contentType에 지정된 charset으로 default값이 지정됨

- 스크립트릿:  <% 자바 코드%>

jsp파일 내부에 java 문법을 사용하고 싶을때 쓸 수 있다. 이 안에선 jsp내장객체를 마음대로 사용이 가능하다. 그 이유는 **스크립트릿 안에 생성된 자바 문법은 _jspService()에 선언한 내장 객체들 바로 아래 출력되게되고 jsp파일의 나머지 것들은 그 아래에 출력문과 함께 삽입**됩니다.
어쨌든 _jspService 내부에 선언

- 선언문 : <%!...%> —→ 특이하게도 _jspService() 바깥에 선언된다.

**서블릿 클래스의 멤버(변수나 메서드)를 선언**할 때 사용하는 태그, 메서드 밖에 선언되기 때문에 jsp파일의 어느 곳에 위치해도 상관이 없습니다.

- 표현식 :  <%= 결과를 반환하는 자바 표현식%>

결과를 반환하는 자바 코드. 예를 들어 변수명(String v1; 의 v1), _jspService 내부 jsp 출력문에 그대로 복사된다. jsp 엔진이 자동으로 표현식 태그가 있는 곳에 자바 코드를 출력문의 인자값으로 복사

## 서블릿에서 뷰 분리하기

현재 서블릿에 text까지 출력문과 함께 선언하여 보관합니다. 이번 절의 목표에 맞게 뷰 부분을 분리해 보겠습니다. 클라이언트로부터 요청이 들어오게되면 서블릿 컨트롤러는 데이터를 준비하여 jsp에 보냅니다. 뷰를 분리하기전 데이터를 담아 전송해줄 값객체 VO(value object)와  데이터 수송 객체DTO(data transfer object)에 데이터를 담겠습니다. 이를 도메인 객체라고 부르기도 합니다.

- **DTO 객체 코드 보기**
    
    
    ```java
    package spms.vo;
    
    import java.sql.Date;
    
    // set의 셋터 메서트 반환타입을 모두 Member로 한 이유는 
    // setter 메서드들은 연속으로 호출하여 값을 할당하기 위함입니다.
    public class Member {
    	protected int no;
    	protected String name;
    	protected String email;
    	protected String password;
    	protected Date createdDate;
    	protected Date modifiedDate;
    	public int getNo() {
    		return no;
    	}
    	
    	public void setNo(int no) {
    		this.no = no;
    	}
    	
    	public String getName() {
    		return name;
    	}
    	public Member setName(String name) {
    		this.name = name;
    		
    		return this;
    	}
    	public String getEmail() {
    		return email;
    	}
    	public Member setEmail(String email) {
    		this.email = email;
    		
    		return this;
    	}
    	public String getPassword() {
    		return password;
    	}
    	public Member setPassword(String password) {
    		this.password = password;
    		return this;
    	}
    	public Date getCreatedDate() {
    		return createdDate;
    	}
    	public Member setCreatedDate(Date createdDate) {
    		this.createdDate = createdDate;
    		
    		return this;
    	}
    	public Date getModifiedDate() {
    		return modifiedDate;
    	}
    	public Member setModifiedDate(Date modifiedDate) {
    		this.modifiedDate = modifiedDate;
    		
    		return this;
    	}
    	@Override
    	public String toString() {
    		return "Member [no=" + no + ", name=" + name + ", email=" + email
    				+ ", password=" + password + ", createdDate=" + createdDate
    				+ ", modifiedDate=" + modifiedDate + "]";
    	}
    	
    	
    }
    
    ```
    

보통 데이터베이스 테이블에 대응하여 값 객체를 정의(이름을 짓는다). 여기서 반환타입을 해당 DTO클래스명으로 선언하는 이유는 아래와 같습니다. 선언 방식의 차이입니다. 스크립팅 언어에서 자주 사용하는 방식입니다.

- **서블릿에서 뷰를 분리하는 작업 코드 보기**
    
    ```java
    
    package spms.servlets;
    
    import java.io.IOException;
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.ResultSet;
    import java.sql.Statement;
    import java.util.ArrayList;
    
    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletContext;
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    
    import spms.vo.Member;
    
    @WebServlet("/member/list")
    public class MemberListServlet extends HttpServlet {
    	private static final long serialVersionUID = 1L;
    
    	@Override
    	public void doGet(
    			HttpServletRequest request, HttpServletResponse response)
    			throws ServletException, IOException {
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet rs = null;
    
    		try {
    			ServletContext sc = this.getServletContext();
    			Class.forName(sc.getInitParameter("driver"));
    			conn = DriverManager.getConnection(
    						sc.getInitParameter("url"),
    						sc.getInitParameter("username"),
    						sc.getInitParameter("password")); 
    			stmt = conn.createStatement();
    			rs = stmt.executeQuery(
    					"SELECT MNO,MNAME,EMAIL,CRE_DATE" + 
    					" FROM MEMBERS" +
    					" ORDER BY MNO ASC");
    			
    			response.setContentType("text/html; charset=UTF-8");
    			
    			// ArrayList는 몇개가 담기든 상관 없다 테이블에 행이 몇개가 되든 ArrayList로
    			// 받으면 다 받을 수 있다.
    			ArrayList<Member> members = new ArrayList<Member>();
    			
    			while(rs.next()){
    				members.add(new Member()
    						.setNo(rs.getInt("MNO"))
    						.setName(rs.getString("MNAME"))
    						.setEmail(rs.getString("EMAIL"))
    						.setCreatedDate(rs.getDate("CRE_DATE"))
    						);
    				
    			}
    			
    			request.setAttribute("members", members);
    			
    			// 서블릿이나 jsp에 작업을 위임할 때 사용하는 객체 RequestDispatcher 는 httpServletRequest에서 얻을 수 있다.
    			// 사용할때는 즉 어떤 서블릿(또는 jsp)에 위임할 것인지 목적지를 제공해줘야한다.
    			RequestDispatcher rd = request.getRequestDispatcher("/member/MemberList.jsp");
    			
    			// 목적지를 설정했고 request의 데이터를 넘길 때 방식을 결정해야합니다.
    			// forward와 include가 있는데 forward는 한방향 즉 해당 데이터에 대한 제어권이 다시 돌아오지 않고
    			// include는 포함으로 제어권을 넘기면 다시 돌아옵니다.
    			rd.include(request, response);
    			
    		} catch (Exception e) {
    			throw new ServletException(e);
    			
    		} finally {
    			try {if (rs != null) rs.close();} catch(Exception e) {}
    			try {if (stmt != null) stmt.close();} catch(Exception e) {}
    			try {if (conn != null) conn.close();} catch(Exception e) {}
    		}
    
    	}
    }
    
    ```
    

위의 작업에서 중요한 부분은 분리하는 과정입니다. 

1. ArrayList<Member> 에 테이블의 행이 넘어 올때마다 담겨지는 것
2. RequestDispatcher를 사용하여 데이터의 목적지를 설정하는 것(HttpServletRequest 에서 받아오는 것)
3. RequestDispatcher의 forward, include 메서드를 사용하여 데이터를 다시 가져올 것인가 보내고 끝낼 것인가를 결정하는 것
4. ServletRequest의 요청을 다루는 기능 외의 값을 보관하는 보관소 기능에서 setAttribute와 getAttribute를 사용하는 법 

이렇게 네가지를 중요하게 봐야합니다.

여기서 잠깐 모든 설정을 마치고 데이터 베이스를 돌리는 와중에 데이터베이스와의 커낵션에서 문제가 생겼습니다. 이유는 사용자 즉 user의 설정이 잘못 되있었다. workbench에 들어가면 

![Untitled](https://user-images.githubusercontent.com/78134917/176821227-9aa0c280-f1b0-49a0-a476-e7ea02d70757.png)

이런식으로 나오게 되는데 root는 사용자 계정명입니다. jdbc context를 설정할 때에 사용자 계정을 study user가 아니라 root입니다.
확인했던 방법은 Mysql에 모든 user를 체크하고 알게 되었습니다. 체크 방법입니다.
우선 cmd를 열고 Mysql의 bin 파일이 있는 곳으로 이동합니다. (cd -사용)
다음으로 mysql -hlocalhost -uroot -p (mysql을 mysql 주소에서 서버의 비밀번호를 입력받아라)
하고 데이터 베이스 설정 use mysql(이 데이터베이스 안에 user 정보 있다.)
select user,host,password from user; 을 작성하고 엔터를 치면
현재 user와 호스트 리스트가 나온다. 

## 서블릿끼리의 작업 위임을 위한 포워딩&인클루딩

다시한번 보자면

포워딩 : A → B(응답완료)

작업에 대한 모든 권한을 전적으로 다음서블릿에 위임한다.(응답완료권한)

인클루딩 : A → B → .... → A(응답완료)

작업 중간에 다른 서블릿으로 제어권 위임 후 다시 돌려받아 나머지 작업 수행 후 응답완료

- **포워딩을 활용한 예외처리 코드**
    
    ```java
    //MemberListServlet의 catch(예외 처리부분)
    } catch (Exception e) {
    			request.setAttribute("error", e);
    			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
    			rd.forward(request, response);
    			
    		} finally {
    
    <%@page import="java.io.BufferedReader"%>
    <%@ page language="java" contentType="text/html; charset=UTF-8"
        pageEncoding="UTF-8"%>
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    <html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>시스템 오류</title>
    </head>
    <body>
    <p>요청을 처리하는 중에 문제가 발생하였습니다. 잠시 후에 다시 요청하시기 바랍니다.
    만약 계속 이 문제가 발생한다면 시스템 운영팀에 연락하시기 바랍니다.</p>
    <%= request.getAttribute("error") %>
    </body>
    </html>
    ```
    
- **인클루딩을 통한 Header, Tail .jsp 삽입 ( jsp에서의 포워딩 인클루딩 사용법)**
    
    ```java
    <body>
    // 주의사항 <jsp:include> 처럼 붙여써야하고 마지막에 '/'로 마무리해줘야한다.
    <jsp:include page ="/Header.jsp"/>
    
    // 결국 이 두 태그는 _jspService내부로 들어가게되면
    // RequestDispatcher rd = request.getRequestDispatcher("/Header.jsp");
    // rd.include(request,response)로 바뀌게되기에
    //<%%> 내부에 위의 태그를 작성해도 무방 하다
    .
    .
    .
    ..
    <jsp:include page ="/Tail.jsp"/>
    </body>
    
    //Header.jsp
    <%@ page language="java" contentType="text/html; charset=-UTF-8"
        pageEncoding="UTF-8"%>
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    
    <div style ="background-color:#00008b; color:#ffffff; height:20px; padding:5px;">
    SPMS(Simple Project Management System)
    </div>
    
    //Tail.jsp
    <%@ page language="java" contentType="text/html; charset=EUC-KR"
        pageEncoding="EUC-KR"%>
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    <div style="background-color:#f0fff0; height:20px; padding:5px; margin-top:10px;">
    SPMS &COPPYWIRHGT LOGAN; 2021
    
    </div>
    ```
    

## 서블릿들의 데이터 공유법

![C72A3006-92AB-4913-A1E8-B32B0643292E](https://user-images.githubusercontent.com/78134917/176821467-78a7a3a2-4c4a-4fbb-bf68-f976e42a24a8.jpeg)


1. ServletContext 
시점 : 하나의 어플리케이션이 시작될때 생성, 종료될 때까지 유지
웹 어플리케이션이 실행되는 동안 모든 서블릿이 이용가능
jsp에서는 application 변수를 통해 
서블릿에서는 ServletContext sc = this.getServletContext() 의 getInitParameter를 사용
2. HttpSession
시점 : 사용자의 최초요청부터 브라우저를 닫을 때까지 유지
서블릿, jsp 어디서나 사용가능 jsp에서는 session 변수로 사용
서블릿에서는 Session 객체 생성한 변수로 사용가능
3. ServletRequest
시점 : 사용자의 요청마다 생성(service()메서드 내부에 존재)해서 클라이언트의 요청을 응답할 때까지 포워딩이나 인클루딩하는 서블릿 사이에서 유용 jsp 에서는 request변수로 사용
4. jspContext
시점 : jsp 내부에서만 사용 가능 pageContext를 변수로 해서 사용

모든 보관소에서 값을 꺼낼 때는 .getAttribute(), .setAttribute()로 사용한다.
이유는 모든 객체보관소의 저장 방식이 Map 객체의 형식을 따르고 있기 때문이다. @

### servlet Context의 활용

만약 한 애플리케이션에 있는 모든 메서드들과 공유하고 싶다면 이 보관소를 사용하면 된다.

- 활용하기 코드
    
    ```java
    package spms.servlets;
    
    import java.sql.Connection;
    import java.sql.DriverManager;
    
    import javax.servlet.ServletConfig;
    import javax.servlet.ServletContext;
    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServlet;
    
    public class AppInitServlet extends HttpServlet{
    	@Override
    	public void init(ServletConfig config) throws ServletException{
    		System.out.println("AppInitServlet 준비중 ..");
    		super.init(config);
    		
    		try {
    			ServletContext sc = this.getServletContext();
    			Class.forName(sc.getInitParameter("driver"));
    			Connection conn = DriverManager.getConnection(
    					sc.getInitParameter("url"),
    					sc.getInitParameter("username"),
    					sc.getInitParameter("password")
    					);
    			
    			sc.setAttribute("conn", conn);
    		} catch (Exception e) {
    			throw new ServletException(e);
    		}
    	}
    	
    	@Override
    	public void destroy(){
    	System.out.println("Application 마무리 ... ");
    	super.destroy();
    	
    	Connection conn = (Connection)this.getServletContext().getAttribute("conn");
    	
    	try {
    		if(conn != null && conn.isClosed() == false){
    			conn.close();
    		}
    	} catch (Exception e) {}
    	}
    }
    
    //web.xml 파일
    <servlet>
      	<servlet-name>AppInitServlet</servlet-name>
      	<servlet-class>spms.servlets.AppInitServlet</servlet-class>
      	<load-on-startup>1</load-on-startup>
     </servlet>
    ```
    

위으 토글을 열어 보시면@WebServlet 어노테이션을 이용하지 않고 직접 DD파일에 서블릿 매핑을 해준 것을 볼 수 있습니다. 조금 특이한 것은 <load-on-startup> 태그를 사용했다는 것입니다. 서블릿을 배치할 때 load-on-startup 태그를 지정하면, 해당 서블릿은 웹 애플리케이션이 시작될 때 자동으로 생성 됩니다.

 또 특이한 점을 발견할 수 있습니다. 다른 서블릿들 즉 서비스를 직접 수행하는 서블릿들은 <sevlet-mapping>태그를 가지고 있지만 방금 설정한 서블릿은 url-mapping 을 선언하지 않았습니다. 매핑을 가지고 있지 않는 서블릿들은 대부분 초기화 즉 서블릿 구동 전에 사전 작업을 하는 서블릿들이 대부분입니다. 앞으로 서블릿에 servlet-mapping이 없다면 사전 작업을 위한 서블릿으로 보겠습니다.

위코드를 보면 servletContext를 활용하는 모습을 볼 수 있습니다.

	sc.setAttribute("conn", conn);

우리는 ServletConext 보관소에 "conn"이라는 키값에 DB접속 정보를 모두 담았습니다. 때문에 이 보관소는 애플리케이션 안에 어떤 서블릿이든 사용이 가능하기 때문에 각각의 서블릿에서 매번 드라이버 가져오고 커낵션에  url,username,password 같은 것들을 일일히 쓸 필요가 없어졌습니다. 정말 단순한게 ServletContext sc = this.getServletContext(); 객체 생성후 sc.getAttribute("conn"); 으로 꺼내 쓰기만 하면 됩니다.

### HttpSession의 활용

로그인 기능을 살짝 구현해 보면서 HttpSession 보관소를 이용해 보겠습니다.

- 세션활용하기
    
    ```java
    package spms.servlets;
    
    import java.io.IOException;
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    
    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletContext;
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import javax.servlet.http.HttpSession;
    
    import spms.vo.Member;
    
    // url을 이런식으로 받으면 이 서블릿으로 이동 servlet-mapping 의 기능을 대신함
    @SuppressWarnings("serial")
    @WebServlet("/auth/login")
    public class LogInServlet extends HttpServlet {
    
    	@Override
    	protected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException,IOException {
    		// login에 관한 jsp 페이지를 만들고 get요청으로 즉 url을 통해서 /auth/login이라는 주소가 들어오면 jsp페이지를 사용자에게 로드시켜줍니다.
    		
    		RequestDispatcher rd = request.getRequestDispatcher("/auth/LogInForm.jsp");
    		rd.forward(request, response);
    		
    	}
    	
    	//jsp 페이지에서 post 방식으로 submit을 하게 되면 doPost가 받게 됩니다.
    	@Override
    	protected void doPost(HttpServletRequest request, HttpServletResponse response)
    					throws ServletException,IOException{
    		
    		Connection conn = null;
    		PreparedStatement stmt = null;
    		ResultSet rs = null;	
    		try {
    			//db 커넥션을 가져오기 위해 ServletContext를 선언해줍니다.
    			ServletContext sc  = request.getServletContext();
    			
    			conn = (Connection)sc.getAttribute("conn");
    			stmt = conn.prepareStatement(
    					"SELECT MNAME,EMAIL FROM MEMBERS"
    					+ " WHERE EMAIL =? AND PWD=?");
    			//로그인 폼에서 받아온 값들을 쿼리 문에 넣고 돌린다.
    			stmt.setString(1,request.getParameter("email"));
    			stmt.setString(2,request.getParameter("password"));
    			
    			
    			rs = stmt.executeQuery(); // 담겨있는 쿼리문을 실행하여 값을 담는다.
    			
    			//쿼리를 실행시키고 결과물을 가져옵니다.(if문의 의미는 rs에 값이 있느냐 없느냐를 true, false로 받는 것입니다.)
    			//로그인 정보에 맞는 행의 정보들을 가져오게 됩니다.
    			//가져온 정보들을 Member value object에 세팅하고  session 보관소에 그 정보를 저장합니다.
    			//이제 이 정보는 로그인을 해지하는 순간까지(즉 고객이 브라우져를 종료하는 시점까지) 계속 유지 될 것 입니다.
    			if(rs.next()){
    				Member member = new Member()
    									.setEmail(rs.getString("EMAIL"))
    									.setName(rs.getString("MNAME"));
    				HttpSession session = request.getSession();
    				session.setAttribute("member", member);
    				
    				response.sendRedirect("../member/list"); //중간 결과 보여주지 않고 바로 목적 서블릿으로 이동
    			}else {
    				//실패 했을 경우에 실패 jsp로 목적지 설정 후 forward 제어권이 더이상 돌아오지 않는 조건으로 실패 jsp페이지로 보낸다.
    				RequestDispatcher rd = request.getRequestDispatcher("/auth/LogInFail.jsp");
    				rd.forward(request, response);
    			}
    		} catch (Exception e) {
    			throw new ServletException(e);
    		}finally{
    			try {if(rs!=null) rs.close();} catch (Exception e) {}
    			try {if(stmt!=null) stmt.close();} catch (Exception e) {}
    		}
    	}
    }
    
    //logout 서블릿
    package spms.servlets;
    
    import java.io.IOException;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import javax.servlet.http.HttpSession;
    
    @SuppressWarnings("serial")
    @WebServlet("/auth/logout")
    public class LogOutServlet extends HttpServlet {
    	
    	@Override
    	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{
    		HttpSession session = request.getSession();
    		session.invalidate();
    		
    		response.sendRedirect("login");
    	}
    }
    ```
    

위의 코드에서 중요하게 보아야 할 부분은 HttpSession session 객체를 가져올때 request.getSession()으로 가져오는 부분과 로그인 정보와 일치하는 행의 정보를 member DTO에 담아서 session 보관소에 세팅하는 과정과 logout 하는 부분에서 session을 깨끗히 청소하기 위해 	session.invalidate();을 사용하고 리프레시(결과값을 제공하지 않고) 말고 Redirect로 바로 로그인 페이지로 보내는 두가지 입니다.

우리가 로그인을 하면서 로그인 정보를 session값에 담았습니다. 하지만 위의 코드에서 볼때는 어딜 봐도 session 보관소에 존재하는 값을 사용하지를 않습니다. 저번에 <jsp:include="">를 활용해서 header 와 tail 정보를 삽입했습니다. 이제 이중 Header .jsp에 로그인 정보를 이용해 보겠습니다.

- session 값 사용하기
    
    ```java
    <%@ page language="java" contentType="text/html; charset=-UTF-8"
        pageEncoding="UTF-8"%>
    <%@ page import="spms.vo.Member" %>
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    <%
    	Member member = (Member)session.getAttribute("member");
    %>
    <div style ="background-color:#00008b; color:#ffffff; height:20px; padding:5px;">
    SPMS(Simple Project Management System)
    <span style="float:right;">
    <%=member.getName() %>
    <a style="color:white;" href="<%=request.getContextPath()%>/auth/logout">로그아웃</a>
    </span>
    </div>
    ```
    

session을 따로 선언하지 않아도 사용이 가능합니다. session에서 꺼낸 값을 page import 로 사용 가능하게 된 member  타입의 변수에 담아주고 <%=..%> 를 사용하여 값을 사용합니다. 

### ServletRequest의 활용

우리가 login 페이지를 url을 통해 열면서 LoginServlet의 doGet 메서드가 실행 되었습니다. 그리고 requestdispetchar를 통해 목적지를 받고 requestdispetchar를 해당 페이지로 전송 시켰습니다.

**forward(request,response), include(request,response)**

### JspContext의 활용

JspContext보관소의 경우에는 jsp페이지를 실행할 때 생기고 완료되면 객체는 제거됩니다. 이는 즉 jsp페이지가 로드될때 jspContext보관소에서 데이터를 꺼내고 로드가 완료되면 보관소는 역할이 끝납니다.

이 jspContext 보관소는 태그 핸들과 사용할 변수들을 저장하기 위해 사용합니다. 예를 들어 <jsp:include page=“/Header.jsp”/>  이 태그는 _jspService() 메소드 안에 삽입 되게되면 자바 코드로 변경되게 되어 있습니다. 이때 이 태그의 변수들을 다루는 객체가 태그 핸들러 객체입니다. 하지만 이 객체는 로컬변수 즉 태그 내부에 있는 변수에 직접 접근을 하지 못합니다. 따라서 jspContext 보관소는 이 변수를 담아 좋고 태그 핸들러가 접근하도록 해주는 것입니다.

### JSP 액션 태그 사용

Jsp페이지에 자바코드를 최소화하는 것이 유지보수에 편합니다. 자바코드를 줄일 수 있는 기술 jsp action 이라고 부르기도 한다. 

![9F73CFC2-14FB-4C31-9920-CBB5F505A23E](https://user-images.githubusercontent.com/78134917/176821403-134e5651-de1b-4596-bc30-fa9d7ecf0d8b.jpeg)
 

<jsp:usebean>의 속성들

- id 속성 : 객체의 이름을 설정합니다. 또는 꺼낸 객체의 참조변수 명으로 사용합니다.
- scope 속성 : 객체를 조회하거나 저장할 때 사용할 보관소를 지정합니다.

```java
page : jspContext, request : ServletRequest,
session: HttpSession, application : ServletContext 를 사용합니다.
아무것도 지정하지 않게되면 page로 지정되게 됩니다.
<jsp:useBean id ="member"
                      scope = "request"
                      class="java.util.ArrayList"
                      type="java.util.ArrayList<spms.vo.Member>"/>

//-------------------------------------------

java.util.ArrayList<spms.vo.Member> members = 
		(java.util.ArrayList<spms.vo.Member>)request.getAttribute("members");
if(members == null){
members = new java.util.ArrayList();
request.setAttribute("members",members);
```

- type 속성 : 참조변수를 선언할 때 사용할 타입의 이름을 지정합니다. 여기서 중요한 것은 경로를 꼭 지정해주어야 한다는 것입니다.

나머지 정리하기 일단 먼저 5.10부터 정리

### DAO(Database Access Object)만들기

DAO는 데이터베이스나 파일 메모리등을 이용하여 생성,조회,변경,삭제하는 역할을 수행

사용 이유 : 여러 업무에서 공통을 사용할 수 있기 때문에 유지보수가 쉬워지고 재사용성이 높음

- DAO객체 만들기 코드
    
    ```java
    
    package spms.dao;
    
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.Statement;
    import java.util.ArrayList;
    import java.util.List;
    
    import javax.servlet.ServletContext;
    
    import spms.vo.Member;
    
    //  dao의 경우에는 데이터베이스와 연결을 담당하는 객체(model component) 입니다.
    public class MemberDao {
    //  connection의 경우에는 데이터베이스와 연결을 하려면 어떤 기능에도 필요합니다.
    // 따라서 인스턴스 변수로 선언해줌으로써 memberDao의 인스턴스가 생성되면(객체주소가 생기면)
    // connection 변수는 memberDao객체 어느 곳에서든 사용이 가능합니다.
    	Connection connection;
    
    //우리는 connection이 필요하지만 ServletContext를 이곳에서 사용하지 못하기때문에
    // setter를 사용하여 객체가 선언된 곳에서 직접 받아와야합니다.	
    	public void setConnection(Connection connection){
    
    		this.connection = connection;
    	}
    	
    //나머지는 일반적으로 우리가 servlet에 선언했던 것들과 같습니다.
    	public List<Member> selectlist() throws Exception{
    		Statement stmt = null;
    		ResultSet rs = null;
    		
    		try {
    			stmt = connection.createStatement();
    			rs = stmt.executeQuery(
    					"SELECT MNO,MNAME,EMAIL,CRE_DATE" +
    				    " FROM MEMBERS" + 
    					" ORDER BY MNO ASC"
    					);
    		List<Member> members = new ArrayList<Member>();
    		
    		while(rs.next()){
    			members.add(new Member().setNo(rs.getInt("MNO"))
    									.setName(rs.getString("MNAME"))
    									.setEmail(rs.getString("EMAIL"))
    									.setCreatedDate(rs.getDate(""))
    									);
    			
    		}
    		
    			return members;
    		} catch (Exception e) {
    			e.printStackTrace();
    			throw e;
    		}finally{
    			try {if(rs != null){rs.close();}} catch (Exception e2) {}
    			try {if(stmt != null){stmt.close();}} catch (Exception e2) {}
    		}
    		}	
    	}
    ```
    

반환 참조변수 타입이 list인데 우리가 선언한 members는 ArrayList객체입니다. 자바에서는 다형성이라는 개념을 가지고 있습니다. 객체(class)끼리 보게되면 상속관계를 따지게 되지만 인터페이스와 class객체를 보게되면 굳이 안따져도 됩니다.

여기서 인터페이스의 개념을 잠깐 살펴보자면 우리가 사용하는 아이콘이라고 보시면 아주 편합니다. 만약 사용자가 인스타그램을 사용한다고 생각해 봅시다. 사용자는 인스타그램 아이콘만을 사용합니다. 내부의 기능이 업그레이드되거나 수정되게 된다하더라도 사용자가 할 일은 거의 없이 사용하기만 하면됩니다.

 자바에서 이야기하는 인터페이스도 이와 같습니다. List 인터페이스를 사용한다면 해당 인터페이스를 참조타입으로 가지고 있는 변수명은 ArrayList 객체도 담을 수 있고 LinkedList객체도 담을 수 있습니다. 큰틀은 원형의 모형을 가지고있어서 원형의 구멍이 뚤린 공간은 다 통과할 수 있지만 원 안의 내용물은 다를 수 있습니다. 틀만 갖추었다면 유두리있게 가는거죠. 즉 유연한거죠

다시 코드로 돌아오면 Connection 정보를 매개변수를 통해 받아왔습니다. 이유는 request가 없기 때문에 ServletContext 객체를 생성하여 변수를 꺼내올 수 없기 때문입니다. 작업에 필요한 객체를 외부로부터 주입 받는 것을 의존성 주입 또는 역제어라고 합니다. (DI 또는 IoC)

- MemberList Servlet에서 DAO  사용하기
    
    ```java
    package spms.servlets;
    
    import java.io.IOException;
    import java.sql.Connection;
    import java.util.ArrayList;
    
    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletContext;
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    
    import spms.dao.MemberDao;
    import spms.vo.Member;
    
    @WebServlet("/member/list")
    public class MemberListServlet extends HttpServlet {
    	private static final long serialVersionUID = 1L;
    
    	@Override
    	public void doGet(
    			HttpServletRequest request, HttpServletResponse response)
    			throws ServletException, IOException {
    		Connection conn =null;	
    		try {
    			ServletContext sc = this.getServletContext();
    			conn = (Connection)sc.getAttribute("conn");
    			
    			MemberDao memberDao = new MemberDao();
    			
    			memberDao.setConnection(conn);
    			
    			request.setAttribute("members", memberDao.selectlist());
    				// 서블릿이나 jsp에 작업을 위임할 때 사용하는 객체 RequestDispatcher 는 httpServletRequest에서 얻을 수 있다.
    				// 사용할때는 즉 어떤 서블릿(또는 jsp)에 위임할 것인지 목적지를 제공해줘야한다.
    			RequestDispatcher rd = request.getRequestDispatcher("/member/MemberList.jsp");
    				// 목적지를 설정했고 request의 데이터를 넘길 때 방식을 결정해야합니다.
    				// forward와 include가 있는데 forward는 한방향 즉 해당 데이터에 대한 제어권이 다시 돌아오지 않고
    				// include는 포함으로 제어권을 넘기면 다시 돌아옵니다.
    			rd.include(request, response);
    			
    		} catch (Exception e) {
    			e.printStackTrace();
    			request.setAttribute("error", e);
    			RequestDispatcher rd = request.getRequestDispatcher("/Error.jsp");
    			rd.forward(request, response);
    			
    		} finally {
    			try {if (conn != null) conn.close();} catch(Exception e) {}
    		}
    
    	}
    }
    ```
    

이제 더이상 서블릿에 데이터베이스와 관련된 코드(쿼리)가 존재하지 않습니다.이렇게 DAO를 사용하여 역할을 분리하고 많이 편리하게 코드 작성이 가능합니다. 이제 코드 연습을 위해 add, delete, update 를 위한 서블릿들도 dao객체를 사용해 보겠습니다.(자율 적으로)

### ServletContextListner와 객체 공유

서블릿컨테이너는 웹어플리케이션의 상태를 모니터링할 수 있도록 웹 어플리케이션 시작에서 종료까지 주요사건에 대한 알림 기능을 제공합니다.

규칙에 따라 객체를 만들어 DD파일(web.xml)에 등록하면됩니다. 이런 식으로 사건이 발생하면 알림을 제공 받는 객체를 '리스너(listener)라고 부릅니다. 

어플리케이션 주요 사건과 인터페이스

![0B356820-74B8-461B-832A-0A96D79BE890](https://user-images.githubusercontent.com/78134917/176821562-349cd83e-1704-4223-999b-3494a9da1cf3.jpeg)


우리는 앞에서 매 서블릿마다 DAO 인스턴스를 생성해서 객체 주소를 만들고 사용했습니다. 하지만 이렇게될 경우 인스턴스를 생성할때마다 메모리에 쌓이게됩니다. 사용하지도 않는데 말이죠. 그래서 이것을 프로그래밍에서는 가비지(GARBAGE)라고 부릅니다. 이렇게 가비지가 쌓이게되면 그만큼 실행 속도도 느려지게됩니다. 그래서 DAO 객체 처럼 여러 서블릿에서 공유하는 객체 같은 경우에는 모두가 공유할 수 있는 ServletContext에 저장해 놓고 서로 공유하는 것이 아주 좋습니다. ServletContext는 웹어플리케이션이 종료될때까지 살아있는 보관소이기 때문이죠. 

그렇다면 DAO 처럼 하나의 웹 어플리케이션에서 공유해야할 객체는 웹어플리케이션이 실행되는 동시에 생성되면 가장 적합할 것 같습니다. 

일전에 우리는 AppInitServlet을 만들고 web.xml에 <load-on-startup>태그를 사용하여 시작할 때 초기화가 필요한 변수들을 초기화하고 생성할 것들을 생성했었습니다. 

이번에는 조금 더 효율적인 방법으로 ServletContextListener 라는 것을 사용하려합니다. 위의 표에서 보다싶이 웹 어플리케이션의 시작과 종료의 알림을 받는 객체는 javax.servlet.ServletContextListener 입니다. 

- ServletContextListener 생성하기
    
    ```java
    package spms.listner;
    
    import java.sql.Connection;
    import java.sql.DriverManager;
    
    import javax.servlet.ServletContext;
    import javax.servlet.ServletContextEvent;
    import javax.servlet.ServletContextListener;
    import javax.servlet.annotation.WebListener;
    
    import spms.dao.MemberDao;
    
    //web.xml에 <listener>태그를 선언해도 되고 아래처럼 어노테이션을 선언해도 됩니다.
    @WebListener
    public class ContextLoaderListnerr implements ServletContextListener {
    	Connection conn;
    	
    // connection을 만듭니다. 만든 connection을 통해 MemberDao의 connection을 세팅합니다.
    // 데이터베이스와 연결된 DAO객체를 ServletContext에 담습니다. 그리고 앱이 종료되면 connection
    //이 종료되게 contextdestroy()에 close(0 메서드를 선언해줍니다.
    	@Override
    	public void contextInitialized(ServletContextEvent event) {
    		ServletContext sc = event.getServletContext();
    		
    		try {
    			Class.forName((String) sc.getAttribute("driver"));
    			conn = DriverManager.getConnection(
    					(String)sc.getAttribute("url"),
    					(String)sc.getAttribute("username"),
    					(String)sc.getAttribute("password")
    					);
    			
    			MemberDao memberDao = new MemberDao();
    			memberDao.setConnection(conn);
    			
    			sc.setAttribute("memberDao",memberDao);
    			
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    	}
    	
    	
    	
    	@Override
    	public void contextDestroyed(ServletContextEvent event) {
    		try {
    			conn.close();
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    	}
    		
    	
    
    }
    ```
    

※정리
매번 DAO 인스턴스를 생성하여 사용하는 것은 메모리상 비효율적이다. 따라서 servletContext에 담아 쓴다. 한번만 선언하기위해 AppInitServlet을 사용하기보다는 ServletContextListener 즉 listener 객체를 사용하여 생성하고 담는다. DAO 객체를 사용하기 위해선 connection이 필수이기 대문에 이 리스너를 상속받아 만든 Listener는 connection 또한 만들어 제공한다. 따라서 ServletContextListner를 상속받은 리스너들은 DAO 객체 생성과 Connection 생성을 담당한다.

### DBConnectionPool

자주 쓰는 객체를 pool에 담아놓고 필요할때마다 빌리고, 사용 후에는 다시 반납하는 방식을 pooling 이라고 합니다. 한정된 자원을 가장 효율적으로 쓸 수 있는 방법을 우리는 대여라고 부르는데 이 대여의 방식을 프로그래밍에서는 pooling 이라고 부릅니다.

**객체풀**: 여러개의 객체를 모아둔 객체 풀
**DB커넥션풀** : 여러개의 DB커넥션을 관리하는 객체

이전에는 하나의 커넥션만을 가지고 진행해도 아무런 문제가 없었습니다. 하지만 이렇게 여러개의 커넥션을 만들어 사용하고자하는 이유는 무엇일까요?

이유는 rollback에 있습니다. 자 예를 들어 3개의 statement가 하나의 connection을 사용하고 각각의 statement는 insert, delete,update의 기능을 담당한다고 생각해봅시다. 이렇게 세개의 statement 중에 하나가 잘못실행되어 rollback을 해야하는 상황이 되었습니다. 하지만 statement에는 rollback기능이 없고 connection에만 rollback 기능이 있습니다. 아... 이제 큰일났죠? 세개의 statement 중 하나만 고장나더라도 나머지도 모두 rollbck해야하는 상황이.... 발생했습니다.

그렇다고 우리가 이전처럼 매 서블릿마다 connection을 생성하고 DAO객체를 초기화해서 사용한다? 이건 또 메모리에 치명적인 영향을 주게 되고 결국 실행 속도가 느려집니다.(커넥션을 생성하는데 느려지는 이유 : 우리가 커넥션을 연결할때마다 데이터베이스 서버는 인증과 권한 심사를 수행하고 요청처리를 위한 준비 작업을 한다.) 

이러한 이유로 우리는 각 statement 즉 데이터베이스가 실행할 쿼리마다  connection을 연결해 주는 것이 좋습니다. 그래서 DBConnecionPool을 사용합니다. 

- DBConnectionPool 생성하기
    
    ```java
    	 package spms.util;
    
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.SQLException;
    import java.util.ArrayList;
    import java.util.List;
    
    public class DBConnectionPooll {
    	String url;
    	String username;
    	String password;
    	
    	List<Connection> connlist = new ArrayList<Connection>();
    	
    	public DBConnectionPooll(String driver, String url, String username, String password) throws Exception{
    		this.url = url;
    		this.username = username;
    		this.password = password;
    		
    		Class.forName(driver);
    	}
    	
    	//커넥션 풀에 내용물이 있는지 검사 후 해당 커넥션이 아직 까지 유효한지 체크(10)은 시간 체크이다. 커넥션 연결을 요청했는데 10 이상의 타임이 지나면 끊어진 것으로 간주
    	public Connection getConnection() throws Exception{
    		if(connlist.size()>0){
    			Connection conn = connlist.get(0);
    			if(conn.isValid(10)){
    				return conn;
    			}
    		}
    		// 아무 커넥션도 없으면 직접 만들어서 반환
    		return DriverManager.getConnection(url,username,password);
    	}
    	
    	public void returnConnection(Connection conn){
    		connlist.add(conn);
    	}
    	
    	public void closeAll() throws Exception{
    		for(Connection conn : connlist){
    			conn.close();
    		}
    	}
    }
    ```
    
- DBConnectionPool 사용하기
    
    ```java
    @WebListener
    public class ContextLoaderListnerr implements ServletContextListener {
    	Connection conn;
    	
    // connection을 만듭니다. 만든 connection을 통해 MemberDao의 connection을 세팅합니다.
    // 데이터베이스와 연결된 DAO객체를 ServletContext에 담습니다. 그리고 앱이 종료되면 connection
    //이 종료되게 contextdestroy()에 close(0 메서드를 선언해줍니다.
    	@Override
    	public void contextInitialized(ServletContextEvent event) {
    		ServletContext sc = event.getServletContext();
    		
    		try {
    			Class.forName((String) sc.getAttribute("driver"));
    			conn = DriverManager.getConnection(
    					(String)sc.getAttribute("url"),
    					(String)sc.getAttribute("username"),
    					(String)sc.getAttribute("password")
    					);
    			
    			MemberDao memberDao = new MemberDao();
    			memberDao.setConnection(conn);
    			
    			sc.setAttribute("memberDao",memberDao);
    			
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    	}
    
    // 우리는 위와 같이 Connection을 생성하여 
    ```
    

우리가 리스너에서 DAO를 생성해서 가장 먼저 만들고 공유할 수 있게 되었습니다. 우리는 이렇게 커넥션 풀을 각 어플리케이션에서 관리하면서 효율적이 되었지만 더 효율적인 방법이 있습니다. 

바로 서버(톰캣)에서 제공하는 커넥션풀을 사용하는 것입니다.

### DataSource와 JNDI

우리는 이제 DataSource서부터 시작해서 JavaEE에서 DB커넥션 풀을 관리하는 방법에 대해서 알아볼 것 입니다. 이번 설명의 목표는 JNDI API를 사용해서 JavaEE 서버 자원에 접근하는 방법을 배웁니다.

javax.sql패키지는 java.sql 패키지의 기능을 보조하기 위해 만든 확장 패키지입니다. 

javax.sql패키지의 주요 기능들 

- DriverManager를 대체할 수 있는  DataSource 인터페이스 제공
- Connection 및 Statement 객체의 풀링
- 분산 트랜잭션 처리
- Rowsets의 지원

### DataSource

DataSource의 이점 두가지

1. 서버에서 관리하기 때문에 데이터베이스나 JDBC 드라이버가 변경되더라도 어플리케이션을 바꿀 필요가 없다.
2. Connection과 Statement 객체를 풀링 할 수 있으며 분산 트랜잭션을 다룰 수 있습니다.

우선 DataSource를 사용하기위해서 환경을 설정해보겠습니다.

### DataSource를 위한 환경 만들기

[http://commons.apache.org](http://commons.apache.org) 사이트에서 DBCP를 다운 받습니다.(commons-dbcp-버전-bin.zip) 압축을 풀고 commons-dbcp-버전.jar 파일을 lib폴더에 넣어줍니다. DBCP 컴포넌트는 내부적으로 POOL 컴포넌트를 사용하기 때문에 POOL 컴포넌트를 위한 준비도 필요합니다. 같은 페이지에서 POOL링크를 클릭하고 같은 방식으로 다운받아 lib폴더에 넣어줍니다.

이제 ContextLoaderListner에 있던 DBConnectionPool 객체를 지워주고 BasicDataSource라는 객체에 의존성을 주입해보겠습니다. 여기서 우리의 주제와 이름이 다른 이유는 DataSource 인터페이스를 구현한 클랙스가 BasicDataSource 이기 때문입니다.

우리가 이제 ContectLoaderListner 의 contextInitialized() 메서드 내부에서 BasicDataSource를 사용했으면 어플리케이션이 종료될때 호출되는 ContextDestroyed() 메서드에서는 우리가 공유하고 있는 자원을 해제해 줘야합니다.

우리가 사용하는 컴퓨터는 많은 자원을 가지고 있지만 무한한 자원을 가지고 있지 않습니다. 우리가 사용하는 유한한 컴퓨터 자원을 조금 더 효율적으로 사용하기 위해서는 쓰지 않는 자원들을 제때에 종료해줄 필요가 있습니다. 이러한 관점에서 어플리케이션이 종료되기 직전 가장 마지막에 호출되는 ContextDestroyed 메서드는 최적의 장소라고 볼 수 있습니다. 공유되는 자원들을 종료하는 것을 잊지 맙시다!

- **DataSource를 활용한 ContextLoaderListner**
    
    ```java
    package spms.listeners;
    
    // Apache DBCP 적용
    import java.sql.SQLException;
    
    import javax.servlet.ServletContext;
    import javax.servlet.ServletContextEvent;
    import javax.servlet.ServletContextListener;
    import javax.servlet.annotation.WebListener;
    
    import org.apache.commons.dbcp.BasicDataSource;
    
    import spms.dao.MemberDao;
    
    @WebListener
    public class ContextLoaderListener implements ServletContextListener {
      BasicDataSource ds;
      
      @Override
      public void contextInitialized(ServletContextEvent event) {
        try {
          ServletContext sc = event.getServletContext();
          
          ds = new BasicDataSource();
          ds.setDriverClassName(sc.getInitParameter("driver"));
          ds.setUrl(sc.getInitParameter("url"));
          ds.setUsername(sc.getInitParameter("username"));
          ds.setPassword(sc.getInitParameter("password"));
          
          MemberDao memberDao = new MemberDao();
          memberDao.setDataSource(ds);
          
          sc.setAttribute("memberDao", memberDao);
    
        } catch(Throwable e) {
          e.printStackTrace();
        }
      }
    
      @Override
      public void contextDestroyed(ServletContextEvent event) {
        try { if (ds != null) ds.close(); } catch (SQLException e) {}
      }
    }
    
    ```
    

이렇게 우리는 처음에 커넥션을 pooling의 형식으로 사용하기 위해서 DBConnectionPool객체를 생성했지만 이제는 더이상 사용하지 않고 BasicDataSource를 사용합니다. 물론 커넥션 풀을 사용해도 되지만 더 좋은 방법이 있으면 사용해야합니다. 그게 기술이 발전하는 이유이니까요.

ContextLoaderListner에서 MemberDao에 커넥션을 건내줍니다. 그럼 이제 MemberDao 소스를 한번 살펴보겠습니다.

- **DataSource를 활용한 MeberDao**
    
    ```java
    package spms.dao;
    
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.Statement;
    import java.util.ArrayList;
    import java.util.List;
    
    import javax.sql.DataSource;
    
    import spms.vo.Member;
    
    public class MemberDao {
    	// connectionPool에서 가져다 쓴다.
    	DataSource ds;
    	public void setDataSource(DataSource ds){
    		this.ds = ds;
    	}
    	
    	public List<Member> selectlist() throws Exception{
    		Connection connection = null;
    		Statement stmt = null;
    		ResultSet rs = null;
    		
    		try {
    			connection = ds.getConnection();
    			stmt = connection.createStatement();
    			rs = stmt.executeQuery(
    					"SELECT MNO,MNAME,EMAIL,CRE_DATE" +
    				    " FROM MEMBERS" + 
    					" ORDER BY MNO ASC"
    					);
    		List<Member> members = new ArrayList<Member>();
    		
    		while(rs.next()){
    			members.add(new Member().setNo(rs.getInt("MNO"))
    									.setName(rs.getString("MNAME"))
    									.setEmail(rs.getString("EMAIL"))
    									.setCreatedDate(rs.getDate("CRE_DATE"))
    									);
    			
    		}
    		
    			return members;
    		} catch (Exception e) {
    			e.printStackTrace();
    			throw e;
    		}finally{
    			try {if(rs != null){rs.close();}} catch (Exception e2) {}
    			try {if(stmt != null){stmt.close();}} catch (Exception e2) {}
    			try {if(connection != null)connection.close();}catch(Exception e2){}
    		}
    		}
    	
    	public void insert(Member member){
    		Connection connection = null;
    		PreparedStatement stmt =null;
    		
    		try {
    			connection = ds.getConnection();
    			stmt = connection.prepareStatement(
    					"INSERT INTO MEMBERS(EMAIL,PWD,MNAME,CRE_DATE,MOD_DATE)"
    					+ " VALUES (?,?,?,NOW(),NOW())");
    			stmt.setString(1, member.getEmail());
    			stmt.setString(2, member.getPassword());
    			stmt.setString(3, member.getName());
    			stmt.executeUpdate();
    			
    		} catch (Exception e) {
    			e.printStackTrace();
    		}finally{
    			try {if(connection != null)connection.close();}catch(Exception e2){}
    			try {if(stmt != null){stmt.close();}} catch (Exception e2) {}
    		}
    	}
    	
    	public Member selectOne(int no) throws Exception{
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet rs = null;
    		try {
    		conn = ds.getConnection();
    		stmt= conn.createStatement();
    		rs = stmt.executeQuery("SELECT MNO,EMAIL,MNAME,CRE_DATE FROM MEMBERS" + 
    						" WHERE MNO=" + no);
    			if(rs.next()){
    				return new Member()
    				  	.setNo(rs.getInt("MNO"))
    			        .setEmail(rs.getString("EMAIL"))
    			        .setName(rs.getString("MNAME"))
    			        .setCreatedDate(rs.getDate("CRE_DATE"));
    			}else{
    				throw new Exception("조회대상을 찾을 수 없습니다.");
    			}
    		} catch (Exception e) {
    			throw e;
    		}finally {
    		      try {if (rs != null) rs.close();} catch(Exception e) {}
    		      try {if (stmt != null) stmt.close();} catch(Exception e) {}
    		    }
    	}
    }
    ```
    

이해하고 넘어가기

위의 소스에서 connection을 반납하는게 아니라 close를 실행했습니다. pool방식을 쓰는게 메모리 측면에서 훨씬 유리하다는 것을 이미 알고 있는데 이렇게 한 이유가 뭘까요? 

DataSource가 만들어주는 Connection객체는 DriverManager가 만들어주는 커넥션 객체를 한번 더 포장한 것이기 때문입니다. (위 포장을 close 해주면 진짜 Connection은 반납됩니다.)

### 서버(톰캣)에서 제공하는 DataSource 사용하기

우선 서버에서 제공해주는 DataSource를 사용하려면 환경설정 먼저 해줘야합니다.

서버프로젝트 폴더에 context.xml 파일을 편집해 줄 겁니다.

- 서버에서 Context.xml 설정하기
    
    ```xml
    <Context>
      <WatchedResource>WEB-INF/web.xml</WatchedResource>
    	<Resource name="jdbc/studydb" auth="Container" type="javax.sql.DataSource"
    	    maxActive="10" maxIdle="3" maxWait="10000"
    	    username="root"
    	    password="1111"
    	    driverClassName="com.mysql.cj.jdbc.Driver"
    	    url="jdbc:mysql://localhost/studydb"
    	    closeMethod="close"/>
    </Context>
    
    name : JNDI의 이름을 의미, Context의 lookup()을 사용하여 자원을 찾을 때 사용한다. java:comp/env디렉터리에서 찾을 수 있다.
    auth : 자원 관리의 주체를 지정한다. Application, Container 가능
    type : 자원의 타입 지정. 패키지경로를 포함한 클래스 이름이어야한다.
    url : db 커넥션 URL
    username : db사용자이름
    password : 사용자 암호
    maxActive : DataSource에서 꺼낼 수 있는 최대 개수. 기본 8개
    maxIdle : DataSource에서 유지할 수 있는 사용하지 않는 Connection 갯수 기본 8개 
    maxWait : 커넥션을 모두 사용 중일때 기다릴 수 있는 최대 초수
    closeMethod : 톰캣 서버 종료시 자원 해제
    ```
    

원하는 어플리케이션에 서버 Context에 입력해 놓은 자원을 찾으려면 해당 어플리케이션에 web.xml(DD파일)에 서버 자원을 참조한다는 선언을 해야합니다.

- 서버에서 Context.xml 설정하기
    
    ```xml
    <resource-ref>
    		<res-ref-name>jdbc/studydb</res-ref-name>
    		<res-type>javax.sql.DataSource</res-type>
    		<res-auth>Container</res-auth>
    </resource-ref>
    
    <resource-ref>
    		<res-ref-name>JNDI이름</res-ref-name>
    		<res-type>리터럴될 자원의 클래스 이름(패키지명 포함 경로)</res-type>
    		<res-auth>자원 관리의 주체</res-auth>
    </resource-ref>
    ```
    

이렇게 어플리케이션의 DD파일에도 참조할 자원의 정보를 선언하고나면 DataSource를 해당 웹어플리케이션에서 사용 가능합니다.

그럼 이렇게 서버자원을 참조하게될때 사용하는 JNDI가 뭘까요?

JNDI란 JAVA NAMING AND DIRECTORY INTERFACE API의 머리글자 입니다. 디렉토리 서비스를 지원하는 API의 한종류이고 이 디렉토리 서비스라는 것은 하나의 어플리케이션에서 다른 어플리케이션에 존재하는 자원을 찾을때 사용하는 서비스라고 생각하시면 편할 것 같습니다.

이제 이렇게 선언해놓은 자원들을 활용하여 어플리케이션에서 직접 Connection을 따는 코드를 작성해 보겠습니다.

- ContextLoaderListner에서 JNDI API 사용하기
    
    ```java
    package spms.listner;
    
    import javax.naming.InitialContext;
    import javax.servlet.ServletContext;
    import javax.servlet.ServletContextEvent;
    import javax.servlet.ServletContextListener;
    import javax.servlet.annotation.WebListener;
    
    import org.apache.tomcat.dbcp.dbcp.BasicDataSource;
    import org.apache.tomcat.jdbc.pool.DataSource;
    
    import spms.dao.MemberDao;
    
    @WebListener
    public class ContextLoaderListner implements ServletContextListener {
    	
    
    	@Override
    	public void contextInitialized(ServletContextEvent event) {
    		try {
    			ServletContext sc = event.getServletContext();
    			InitialContext initialContext = new InitialContext();
    			DataSource ds = (DataSource)initialContext.lookup("java:comp/env/jdbc/studydb");
    			//리스너의 핵심 부분 앱실행의 가장 처음에 커넥션 객체를 만들어서 memberDao에 담고 ServletContext에 담아 놓는다.
    			MemberDao memberDao = new MemberDao();
    			memberDao.setDataSource(ds);
    			
    			sc.setAttribute("memberDao", memberDao);
    			
    		} catch(Throwable e) {
    			e.printStackTrace();
    		}
    	}
    
    	
    	
    	@Override
    	public void contextDestroyed(ServletContextEvent event) {}
    }
    ```
    

이렇게 InitialContext 객체를 이용하면 JNDI 이름으로 등록되어 있는 서버자원을 찾을 수 있습니다.

JAVA:COMP/ENV 는 데이터베이스자원을 찾을 때 사용하는 JNDI 구별자 입니다. 그리고 어플리케이션의 종료 가장 직전에 호출되는 destoryed 메서드에 아무것도 적지 않은 것은 우리 가 서버 Context.xml에 선언해놓은 closeMethod가 close이기 때문입니다.

자 이렇게 우리는 5절에서 뷰컴포넌트를 정의하는 jsp 부터 Model 컴포넌트를 분리하는 Dao까지 정리해 보았습니다. 다음 절에서는 우리가 이해한 MVC 구조를 가지고 미니 MVC모델을 만들어 보겠습니다.
