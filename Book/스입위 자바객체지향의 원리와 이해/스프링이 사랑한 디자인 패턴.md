# 스프링의 디자인 패턴
### 목차
- [#1.어댑터 패턴](#-1------)
- [#2.프록시 패턴](#-2------)
- [#3.싱글턴 패턴](#-3------)
- [#4.템플릿 메서드 패턴](#-4----------)
- [#5.팩터리 메서드 패턴](#-5----------)
- [#6.전략패턴](#-6----)
- [#7.템플릿 콜백 패턴](#-7---------)

들어가기 전에 우선 디자인 패턴을 한국말로 바꾸면 자주 쓰이는 설계 방식이라고 볼 수 있다. 실제 개발 현장에서 비즈니스 요구사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중 많은 사람들이 인정한 
베스트 프렉티스를 정리되있고 디자인 패턴은 당연히 객체 지향 특성과 설계 원칙을 기반으로 구현돼 있다. 
그래서 must라고 보긴 어렵지만 지켜지면 가독성이 좋고 유지보수에 용이한 코드들을 작성할 수 있다. 그럼 이제 하나씩 살펴보자.

## #1.어댑터 패턴 
변환기(abeptor)의 역할을 한다고 보면 된다. 두개의 메서드가 행위는 같은데 이름은 다르다. 클라이언트는 뭘 쓰든 하나의 메서드명으로 사용하는게 마음이 편하다.(인터페이스를 쓰지 않는다는 가정하의 이야기다.)
중간 다리 역할을 하는게 좋다고 생각한다. 아래의 그림을 보면 이해가 조금 된다.
<img width="611" alt="스크린샷 2022-05-19 오후 12 09 59" src="https://user-images.githubusercontent.com/78134917/169196126-04d1ac7f-275a-4b18-9c93-e9aa30877fc9.png">

## #2.프록시 패턴 & 데코레이터 패턴 
> 프록시 패턴 : 제어의 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴 
> 데코레이터 패턴 : 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴
프록시 패턴은 흐름을 제어하기 위해서 사용된다. 내가 사용하는 메서드의 전,후로 무언가를 추가하고 싶다면 프록시 패턴을 사용하면된다. 하지만 실제 실행 코드에 관여해서는 안된다.  
- 프록시는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다. 
- 프록시는 실제 서비스에 대한 참조변수를 갖는다.(합성 : 실제 서비스 코드 실행을 위해 - 아래의 목적과 같다.)
- 프록시는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.  
- 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다. 

기본적으로 프록시와 데코레이터는 비슷하게 진해행된다. 한가지 차이점은 데코레이터 패턴은 실제 실행 서비스의 반환값에 장식을 더하거나 추가한다. 

## #3.싱글턴 패턴  
> 클래스의 인스턴스를 하나만 만들어서 사용할때 사용하는 패턴  
- new 연산을 객체 외부에서 사용할 수 없도록 생성자를 private으로 선언 
- 유일한 단일 객체를 반환할 수 있는 정적 메서드가 필요
- 유일한 단일 객체를 참조한 정적 참조 변수 필요. 
## #4.템플릿 메서드 패턴 
> 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴
상위 클래스에 공통 로직을 수행하는 템플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상 메서드 또는 선택적으로 오버라이딩할 수 있는 훅 메서드를 두는 패턴을 템플릿 메서드 패턴이라 한다.(추상 클래스와 추상메서드가 사용된 패턴 ) 
상위 추상 클래스의 공통 로직 메서드에 하위 클래스에서 구현한 추상 메서드를 사용하는 것.  

## #5.팩터리 메서드 패턴  
객체를 생성 반환하는 메서드를 팩토리 메서드, 오버라이드된 메서드가 객체를 반환하는 패턴.  

## #6.전략패턴   
디자인 패턴의 꽃!  

## #7.템플릿 콜백 패턴 
