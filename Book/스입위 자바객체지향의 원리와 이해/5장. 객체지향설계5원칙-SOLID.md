앞서 이야기한 객체지향의 4특성인 캡슐화, 상속, 추상화, 다형성 이 네가지는 도구로써 존재한다고 했다. 이것들을 이용해 객체지향언어를 가지고 객체지향적 프로그래밍을 올바르게 설계하려 시도하면서 나온 
약간의 약속들이 존재한다. 이 특성들을 모두 지켜가면서 개발을 한다는 것은 쉽지 않다. 하지만 알아두면 좋다. 그럼 이제 알아보자.   

> - SRP(single responsibility principle) : 단일 책임의 원칙을 의미한다. 
> - OCP(open closed principle) : 개방 폐쇄의 원칙
> - LSP(liskov substitution principle) : 리스코프 치환의 원칙
> - ISP(interface segregation principle) : 인터페이스 분리의 원칙
> - DIP(Dependency Inversion principle) : 의존 역전 원칙

이렇게 다섯가지가 존재하는데 이 원칙들은 한번에 생겨난 것들이 아니다. "응집도를 높이고 결합도는 낮춰라"라는 고전적 원칙을 객체지향의 관점에서 재정립한 것이다.  

여기서 잠깐 응집도와 결합도에 대해서 알아보고 가자.  
좋은 소프트웨어 설계에 있어서 결합도를 낮추고 응집도를 높이는 것이 중요하다고 한다. 이게 무슨말일까?  
결합도가 낮다 : 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.  
응집도가 높다 : 모듈은 하나의 책입에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.  
결국 모듈 및 객체를 최대한 독립적으로 사용하게 만드는 것이 중요하다는 말이다. 이러한 것들을 잘 지키기위해 관심사의 분리가 이루어지고 잘 분리된 것들끼리 서로 사용할 수 있게 하기위해 전략패턴 등이 생겨난 것이다.  


하나씩 까보자.   
## #1. **단일책임원칙**  
속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있는 개념인 것을 잊지말자.  
위의 멤버들이 모두 각각 하나의 책임만 가지고 있게 만드는 것이다. 예를들어 메서드에 계산을 하는 역할과 시스템을 종료하는 역할(기능)이 모두 존재한다고 하면 계산을 하기위해선 시스템이 무조건 종료되어야만 한다.  
마치 하나의 버튼에 두개의 역할이 존재하는 것과 비슷하다고 생가하면될 것 같다. 이처럼 여러개의 책임을 가지고 있으면 사람이 이해하기에 너무 복잡해지는 경향이 있다. 따라서 프로그래미을 할때는  
왠만하면 하나의 역할 하나의 책임만 주어지는게 다른 인간을 위해서다 마땅한 판단이다.   
  
  
메서드가 단일책임 원칙을 지키지 않은 사례 중 대표적인 것이 메서드 내부에 if 분기 문이 들어가 있는 경우이다.  
  
   
## #2. **개방 폐쇄의 원칙 - 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야한다.**  
여기서는 클라이언트라는 개념을 조금 짚고 넘어가야겠다. 클라이언트라면 우리는 고객을 생각하기 쉽다. 내가 생각하기에 프로그래밍 세계에서 클라이언트는 사용자의 입장이되면 모두 클라이언트라고 부를 수 있을 것같다. 
한 객체가 다른 객체를 new 연산자를 통해 사용하고 있다면 다른 객체를 사용하는 객체는 클라이언트라고 볼 수 있다. 이제 다시 본론으로 돌아가보자.  
개방 폐쇄 원칙은 클라이언트에게는 닫혀있고 자신의 확장에는 열려있다는 말이다. 이 개념을 이해할 때 인터페이스 혹은 추상 클래스를 떠올려보면 좋다. 사용자의 입장에서는 인터페이스를 사용하면 인터페이스의 동작이  
어떻게 수행되던간에 상관 없이 사용이 가능하다. 이러한 구조는 인터페이스(동작 제공자)에게도 아주 편하다. 이유는 내가 어떻게 로직을 수행해도 클라이언트에 영향이가는 상황은 발생하지 않기 때문이다.  
이렇게되면 개발의 유연성이 올라가게된다.

이러한 원칙들로 따져봤을 때 개방 폐쇄 원칙이 지켜지지 않는다면 물론 프로그래밍은 가능하겠지만 객체지향의 큰 장점인 재사용성, 유연성, 유지보수성 등을 얻을 수 없다.  

  
## #3. **리스코프 치환의 원칙 - 하위 클래시의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야한다.**  
> 하위 클래스 is kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.  
> 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다.  


## #4. **인터페이스 분리의 원칙** 
인터페이스는 그 역할에 충실한 최소한의 기능만 공개하라는 것이 이 시대 객체 지향 스승들의 가르침이다. 인터페이스를 해석할 때 "~할 수 있는"이라는 기준으로 만드는 것이 정석이다.  
  
## #5. **의존 관계 역전의 원칙 - 자신보다 변하기 쉬운 것이 의존하지 마라.**
  
  
이 모든 것을 관통하는 개념이 하나 더 있다. **관심사의 분리(Seperation of Concerns)**  
관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체는 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것이다.  
