## #1. IP헤더가 가진 TTL의 필요성
![IMG_C219FD51FBE7-1](https://user-images.githubusercontent.com/78134917/176673681-d92abe39-b3f8-4222-8b22-939ee633a078.jpeg)
위의 그림처럼 라우터끼리의 통신인 인터넷 내부에서는 Looping이라는 현상이 발생할 수 있다. 간단히 말해 패킨(Frame)이 몇개읠 라우터를 빙빙 도는 현상이다. 이 현상이 발생하면 라우터의 CPU에 부하가 발생한다. 부하가 커지면 서버가 죽을 수 있고 그렇게 되면 관련된 모든 서버 장치들이 다운되는 상황이 발생할 수 있다. 이런 것들을 방지하기에 TTL(Time To Live) 패킷의 생명주기를 관리한다.  
TTL의 기본적인 길이는 8Bit이다. 총 256(0~255)이다. 이 길이가 라우팅 될때마다.(한번의 hoop을 뛰어넘을 때마다.) 하나씩 감소한다. 그렇게 TTL이 모두 소진되면 라우터는 더이상 라우팅을 진행하지 않는다. 설정에 따라 ICMP(internet controll message protocol)을 사용하여 소스(출발지 주소)주소에 '야 너 패킷 목적지로 전달 안됐어.'라고 알려주거나 설정하지 않으면 그냥 그 패킷은 죽는다.  

## #2. MTU와 Packet의 단편화  
단편화를 먼저 알아보자. 단편화는 나누는 것이다. MTU(maximum transfer unit)에 따라 패킷을 나눠보내야하는 경우가 발생한다. 내 피씨에서 1500짜리 Packet을 만들고 목적지로 전송했다. 라우팅을 진행하면서 목적지를 찾아가게되는데 중간에 어떤 라우터의 MTU가 1400이되는 경우가 생길 수 있다. 해당 라우터의 성능이 1400으로 패킹할 수 밖에 없기 때문에 어쩔 수 없이 패킷의 단편화가 진행된다.(이렇게 되는 이유는 라우팅되어서 목적 MAC주소에 있는 라우터에 도착하면 Frame을 벗기고 다시 Frame화 시킨다. 여기서 Packet의 크기를 확인한다.)

기존 패킷의 segment의 길이를 1400맞춰 자른다. 그리고 따로 빼서 IP헤더를 붙이고 따로 목적지로 전송한다. 재조림의 과정은 목적지 서버가 담당하고 재조립이 가능한 이유는 IP 헤더에 존재하는 ID가 동일하기 때문에 재조립이 가능하다. 또한 데이터가 어디서 짤렸는지에 대해 알 수 있는게 헤더에 offset이라는 곳에 저장되기 때문이다. header와 Payload가 만나는 접점은 Offset이 0이다. 분할되어 ip헤더만 존재하는 패킷으 헤더에 짤린 위치의 오프셋이 저장된다.(예로 머리 패킷의 payload의 길이가 0~ 1200이라면 자식 패킷은 1200 ~ 1460이 된다.)  

다시 생각해봐도 굉장히 비효율적이다. 네트워크 성능을 측정할때 bps도 있지만 pps로 측정하기도 한다. pps는 패킷의 개수에 따라 좋고 나쁜을 결정하는 지표이다. 패킷의 단편화는 패킷의 수를 늘리기 때문에 성능을 낮춘다. 때문에 패킷을 단편화 시키는 것보다. 목적 서버와 출발 서버에서 패킷의 크기를 하향시켜 통신하는 것이 올바른 것이다.  
  
사실 요즘은 이러한 일이 덜 발생하지만 VPN 통신을 할 경우에 발생하기도 한다.(그냥 MTU의 제한 크기를 낮추면 그만이다.)  

  
## #3. UDP에 대한 간단한 정보  
UDP의 데이터 단위는 Datagram이다. 
