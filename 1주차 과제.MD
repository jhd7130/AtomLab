# Data Base

## Index
### Index가 뭔가요?
Index는 '색인'이라는 뜻을 가집니다. 색인의 뜻은 아래와 같습니다.

<img src="https://user-images.githubusercontent.com/78134917/153604198-de8e2cdb-9808-4ee2-87c7-1d7ad106d3ed.png" width="700" height="200"/>

아주 두꺼운 전공서적이나 책들을 보면 맨 뒷장 언저리에 '가나다'순으로 나열된 색인을 볼 수 있습니다. 색인은 원하는 자료를 두꺼운 책에서 쉽게 찾을 수 있도록 도와줍니다. 
데이터베이스에서의 인덱스도 같은 일을 합니다. 1억 페이지가 넘는 책(=테이블)에서 원하는 자료(=데이터)를 쉽게 찾기 위해 존재하는 색인(=인덱스 테이블) 

> 데이터베이스에서 인덱스란 테이블에 대한 검색 성능(SELECT)을 향상시키기 위한 자료구조의 한가지입니다. 
<br/>
<br/>

### Index사용 이유
**원하는 데이터 조회시 불필요한 작업을 줄여 비용을 아끼기 위함** 
만약 1억건의 데이터가 있다고 치겠습니다. 이 1억건의 데이터 중 자주 사용되는 데이터들은 메모리에 올라가 조회 시 빠르게 찾아올 수 있습니다. 하지만 그렇지 않은 경우에 데이터베이스는 
이 1억건의 데이터를 모두 조회합니다. 이러한 조회 방식을 **FULL TABLE SCAN** 방식이라고 합니다. **FULL TABLE SCAN** 조회 방식을 개선하기 위해 인덱스라는 자료구조가 생겨났습니다.
실제 DB를 사용하면서 인덱스를 쓰는 이유를 살펴보자면 아래와 같습니다.
<br/>
> * WHERE 구문과 일치하는 열을 빨리 찾기 위해.
> * 특정 열을 고려 대상에서 빨리 없애 버리기 위해.
> * 조인 (join)을 실행할 때 다른 테이블에서 열을 추출하기 위해.
> * 특정하게 인덱스된 컬럼을 위한 MIN() 또는 MAX() 값을 찾기 위해.
> * 사용할 수 있는 키의 최 좌측 접두사(leftmost prefix)를 가지고 정렬 및 그룹화를 하기 위해.
> * 데이터 열을 참조하지 않는 상태로 값을 추출하기 위해서 쿼리를 최적화 하는 경우.

### 인덱스의 생성원리
B+Tree 알고리즘으로 색인화를 하고 인덱스 자료구조 형식을 가지게 됩니다. B+Tree(Balanced Tree)에 대해선 아래에 더 자세히 알아보도록합시다. 
지금은 'Binary Tree > B-tree(Balanced Tree) > B+ tree'의 순서로 확장되었으며 이로 인해 색인화 과정에서 데이터가 한쪽으로 치우치지 않고 균형있는 tree 구조로
생기도록 도와주는 알고리즘이라고 보면 좋습니다.

어떤 테이블의 하나의 컬럼을 인덱스로 지정합니다. 그렇게 되면 초기 테이블 생성시 만들어지는 MYD,MYI,FRM 3개의 파일중에서
MYI에 해당 컬럼을 색인화(인덱싱)하여 저장합니다(인덱스 테이블 생성). 그래서 SELECT문으로 조회할때 WHERE 조건문에 인덱스로 지정한 컬럼으로 조건을 주게되면 마스터 테이블을 조회하지 않고
MYI파일을 검색해 해당 ROW를 찾습니다.그렇지 않을 경우 위에서 이야기한 것과 같이 FULL SCAN을 진행하여 시간이 더 소요됩니다.

### Index의 종류
여러 종류의 Index가 있지만 주로 많이 언급되고 사용되는 Index는 Clustered Index와 Non Clustered Index 두가지 입니다.
둘의 차이는 뭘까요? 우선 cluster의 뜻을 보면 '무리'라는 뜻을 가지고 있습니다. 이렇게 생각하면 위의 두가지를 '무리지어진 인덱스'와 '무리지어지지 않은 인덱스' 정도로 해석할 수 있습니다.


* **Clustered Index** (= 사용자 지정이 아닌 MYSQL 자동지정 생성 인덱스, 정렬된)


Clustered Index는 데이터가 테이블에 물리적으로 저장 되는 순서를 정의(설정)한다. 즉, 클러스터 형 인덱스는 특정 컬럼을 기준으로 데이터들을 정렬시킨다.

1. 테이블에 AUTO INCREMENT로 생성된 PK 컬럼이 있다면 데이터베이스가 자동으로 해당 컬럼을 Clustered Index로 지정합니다.
2. pk가 없다면 Unique key를 Clustered Index로 지정합니다.
3. unique컬럼도 하나도 없다면? MySQL에서 내부적으로 Hidden Clustered Index Key (row ID)를 만들어 Clustered Index로 사용합니다.
4. 테이블 데이터는 오직 한 가지의 방법으로만 정렬되기 때문에 오직 테이블 당 하나의 클러스터 형 인덱스만 존재할 수 있다. 즉, 정렬 기준으로 오직 하나의 컬럼만을 선택할 수 있습니다.
5. Database에서 primary key의 제약조건(constraint)은 클러스터 된 인덱스를 자동으로 생성하기 때문에 우리가 일반적으로 테이블을 생성할 때 특정 컬럼에 primary key를 지정했다면, 자료가 자동으로 정렬되는 것입니다.
6. primary key를 설정하지 않은 테이블에 무작위로 데이터를 insert하고, 테이블을 조회하면 뒤죽박죽인 테이블을 보게될 것입니다.

그래서 Clustered는 왜 사용하는가?
삽입/삭제를해도 자동으로 데이터를 정렬해주기 때문이다(5번과 같음). 문제는 여기서 발생합니다. 우리가 한 배열의 중간에 값을 삽입하려고 하면 해당 위치 뒤쪽에 있는 공간들을 한칸씩 뒤로밉니다.
그리고 새로운 데이터를 삽입합니다. 삭제도 이와 마찬가지 입니다. 데이터가 적다면 문제가 안되지만 1억건이라고 했을때는 말이 달라집니다. 따라서 아래와 같은 경우에서 사용하는 것을 권장합니다.
* 테이블 데이터가 자주 업데이트 되지 않는 경우
* 항상 정렬 된 방식으로 데이터를 반환해야하는 경우
* 테이블은 정렬되어있기 때문에 ORDER BY 절을 활용해 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.읽기 작업이 월등히 많은 경우, 이때 매우 빠르다.

<img src="https://user-images.githubusercontent.com/78134917/153634902-e06d6359-61ae-46e0-beee-2da641207c51.png" width="700" height="500"/>



* **NonClustered Index** (= 사용자 지정생성 인덱스, 정렬되지 않은)
1. 테이블에 저장 된 물리적인 순서에 따라 데이터를 정렬하지 않는다. 즉, 순서대로 정렬되어 있지 않다.
2. 논 클러스터 형 인덱스는 테이블 데이터와 함께 테이블에 저장되는 것이 아니라 별도의 장소에 저장된다. 마치, 위 책에서 index 페이지를 따로 나눈것 처럼 말이다.
3. 하나의 테이블에 여러개의 논 클러스터 형 인덱스를 설정할 수 있다.

어떤 경우에 nonClustered Index 생성?
* where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자할 때
* 데이터가 자주 업데이트 될 때
* 특정 컬럼이 쿼리에서 자주사용 될 때

<img src="https://user-images.githubusercontent.com/78134917/153635772-657973eb-a5d9-495a-a8ea-f34a33f60b0a.png" width="700" height="500"/>


**두가지 인덱스의 차이 정리**
* Clustered 인덱스는 테이블당 오직 한개만 존재한다. 반면에 Non-Clustered 형은 테이블 당 여러개의 인덱스를 생성할 수 있다.
* Clustered 인덱스는 오직 테이블을 정렬한다. 그러므로 별도의 공간을 필요로하지 않는다. Non-Clustered 인덱스는 저장되는 별도의 공간(약 10%)이 필요하다.
* Clustered 인덱스는 통상적으로 데이터를 찾는데 추가적인 스텝을 거치지 않기 때문에 Non-Clustered 인덱스보다 속도가 빠르다.
* Clustered 인덱스는 데이터를 삽입할 때, 모든 테이블에 존재하는 데이터들의 순서를 유지해야하므로 많은 비용이 발생한다. Non-Clustered는 별도의 공간에 인덱스를 생성해야하기 때문에 추가작업이 필요하다.
<br/>
<br/>

## 정규화

### 정규화란?
정규화는 데이터의 중복을 방지하기 위해 만들어졌다. 하나의 테이블이 수정되면 수정된 테이블과 관계가 정의된 모든 것들에 영향을 줄 수 있게 만드는 필터링으로 보면 좋습니다.
이러한 정규화 개념에의해 최초의 RDBMS인 Oracle이 만들어 졌다. 정규화에 필요한 작업(옵션)에 따라 제1 정규,2정규 3정규화로 진행되게 되며 일반적으로 3정규화 작업까지 마친 테이블을
정규화 되었다고 이야기합니다.

> 정규화된 테이블은 중복된 데이터를 허용하지 않음으로써 데이터의 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.


<br/><br/>
만약 정규화를 하지 않았을 경우에 생기는 문제점들이 있습니다. 이를 이상현상이라 부르고 대표적으로 세가지 이상현상 있습니다.(RDBMS 소프트웨어를 쓰지 않는 상황이라고 가정하면 좋습니다.)
1. 갱신이상(수정,update시 발생)
어떤 학원에서 김철수라는 사람이 3가지 강좌를 수강하고 있습니다. 학원에서는 하나의 테이블로 학원을 관리하고있습니다. 테이블에는 강좌당 강좌정보와 김철수씨의 정보가 하나의 튜플에 모두 기록되어 있습니다. 김철수라는 사람이 이사를 가서 주소가 변경되었습니다. 튜플에서 김철수 씨를 찾아서 주소를 변경해야합니다. 500명의 학생 중에 김철수씨의 정보를 모두 변경하려면 찾기가 굉장히 힘들 뿐더러 3개를 모두 찾지 못하는 경우가 발생할지도 모릅니다. 결국 갱신(update)가 제대로 이루어지지 못하고 데이터는 신뢰성을 잃게됩니다.

> 반복된 데이터 중에 일부만 수정하면 데이터의 불일치가 발생합니다.

2. 삽입이상(신규,insert시 발생)
학원에서 강좌를 신설하려합니다. 새로운 강좌를 데이터로 기록하려면 수강생이 없음에도 불구하고 불필요한 자료까지 삽입해야합니다.
> 불필요한 정보를 함께 저장하지 않고는 어떤 정보를 신규저장하는 것이 불가능합니다.

3. 삭제이상 (삭제,delect시 발생)
학원에서 수강생이 한명인 강좌를 폐쇄하려합니다. 수강생은 해당 강좌하나만 수강하고 있습니다. 학원에서는 해당 세션을 마지막으로 강좌를 폐지했습니다. 이제 학원에 해당 강좌가 존재하지 않기 때문에 데이터를 삭제합니다. 여기서 강좌 정보 자체를 삭제하려면 수강했던 수강생의 정보도 모두 삭제해야합니다. 

> 이처럼 유용한정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능합니다.

이러한 이상현상들을 제거하기 위해서 정규화 작업을 진행합니다.


#### 1정규화
릴레이션(=테이블)에 있는 컬럼들의 각 엔티티들이 원자성을 가져야한다는 규칙을 가집니다. 

값의 원자성이 지켜지지 않는 컬럼이 존재한다면 따로 원자 도메인(해당 컬럼에 사용할 수 있는 엔티티를 정의해놓은 집합) 테이블을 생성하여 분해해야합니다. 이 제1정규화를 거친 데이터는 컬럼의 값이 원자성을 지니게됩니다. 


#### 2정규화
제 1 정규화를 마친 데이터에 한해서 **부분함수적 종속을 제거하여 완전(충분한) 함수적 종속을 만족하는 정규형입니다.(제 2정규화를 위해선 1정규화가 필수입니다.)**
|회원번호|수강과목|성적|이름|
|------|---|---|---|
|k001|필기|80|김철수|
|k002|필기|90|김정기|
|k002|실기|100|김정기|
|k001|실기|90|김철수|

테이블의 정보 중에서 하나의 컬럼 값에 의해서 다른 컬럼의 값이 정해지는 경우가 있습니다. 여기서 값을 결정하는 컬럼을 결정자, 값이 결정되는 컬럼을 종속자라고 이야기합니다.
결정자 컬럼은 대개 기본키로 많이 쓰이게 됩니다. 기본키가 두개인 경우가 생기게되는데 이를 복합키라고 부릅니다.
이제 위 테이블을 보면 회원번호와 수강과목이 모두 존재해야 성적을 찾을 수 있습니다. 여기서 회원번호와 수강과목이 복합키로써 결정자 역할을 합니다. 하지만 자세히보면 회원번호는 복합키의 부분키로서 이름의 결정자역할 또한 하게됩니다. 하나의 테이블 내부에서 결정자가 두개, 종속자가 두개가 존재합니다. 이렇게 될 경우 데이터의 중복이 발생하게 됩니다. 따라서 부분종속이 이루어지고있는 회원번호에 따른 이름은 따로 테이블을 분리하는게 제 2 정규화의 핵심입니다. 

#### 제 3정규화
1,2 정규화 작업이 끝나면 정규화가 된 테이블가 되기위한 마지막 관문인 제 3 정규화 작업이 있습니다. 제 3정규화 작업에서 하는 필터링은 이행적 종속성을 체크하는 일입니다. 
이행적 종속성이라는 것이 뭘까요? 아래 테이블을 보면서 이야기해보겠습니다.

|책번호|책이름|책가격|작가번호|작가이름|작가주소|
|------|---|---|---|---|---|
|k001|함께자라기|15000|author_001|김창준|서울|
|k002|jpa프로그래밍|25000|author_002|김영한|경기|
|k002|AWS실습|28000|author_003|김동욱|충청|
|k001|자바의정석|35000|author_004|남궁성|인천|
|k002|OS 실습|23000|author_003|김동욱|충청|

여기서 기본키는 책번호 하나이고 나머지는 책번호에 종속되어 있습니다. 하지만 잘 보게되면 작가번호는 키가 아님에도 불구하고 작가이름,작가주소의 결정자가 될 수 있습니다. 이를 이행적 종속성이라고 합니다. 키가 아닌데 종속성을 가지고 있는 것들을 테이블에서 분리시키는 것이 제 3정규화 작업업니다. 정리해서 보자면

1. 모든 key가 아닌 컬럼(non-key)은 key 컬럼(속성)에 완전히 종속 되어야 한다.
2. 모든 non-key 컬럼은 key 컬럼(속성)에만 종속 되어야 한다.
3. 그래서 key가 아닌 값에 주목해서 확인해야한다.

## 트렌잭션
### 트랜잭션이란?
하나의 논리적인 업무단위를 위해 사용하는 읽기/쓰기를 의미합니다. 
<br/>![85AC3938-D929-4598-AF46-A1903A6267AC](https://user-images.githubusercontent.com/78134917/153718588-6b3d4cc1-4081-4ded-87ca-33887785abfb.jpeg)

트랜잭션처리에 대한 신뢰를 보장하기 위해 지켜야하는 성질들이 존재합니다. ACID라고 약어로 이야기하는데 하나씩 이야기 해보겠습니다.

트랜잭션은 하나의 업무단위로 묵여있는 물리적 명령어 단위들이 모두 실행되거나 모두 실패하거나 둘 중에 하나만 해야합니다. 이를 원자성 **(Atomicity)**이라고 합니다. 
트랜잭션으로 인해 수정된 데이터는 엔티티가 변경 되어야하지 데이터 타입이 변경되면 안됩니다. 이를 **일관성(Consistency)** 이라고 합니다.
하나의 세션이 트랜잭션을 수행하고 있을 때 다른 세션(사용자)는 해당 트랜잭션에서 사용하는 레코드에 접근하지 못합니다. 즉, 트랜잭션끼리는 서로 간섭하지 못합니다. 이를 **격리성 ( Isolation )** 이라고 합니다.
트랜잭션이 완료되고 커밋을 한 후의 성공적으로 수정된 데이터들은 영원히 유지되어야합니다. 이를 **지속성 ( Durability )** 이라고합니다.






### 참조한 페이지
https://gwang920.github.io/database/clusterednonclustered/
https://mangkyu.tistory.com/110
https://victorydntmd.tistory.com/129
# Operating System
