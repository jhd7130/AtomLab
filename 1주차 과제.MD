# Data Base

## Index
### Index가 뭔가요?
Index는 '색인'이라는 뜻을 가집니다. 색인의 뜻은 아래와 같습니다.

<img src="https://user-images.githubusercontent.com/78134917/153604198-de8e2cdb-9808-4ee2-87c7-1d7ad106d3ed.png" width="700" height="200"/>

아주 두꺼운 전공서적이나 책들을 보면 맨 뒷장 언저리에 '가나다'순으로 나열된 색인을 볼 수 있습니다. 색인은 원하는 자료를 두꺼운 책에서 쉽게 찾을 수 있도록 도와줍니다. 
데이터베이스에서의 인덱스도 같은 일을 합니다. 1억 페이지가 넘는 책(=테이블)에서 원하는 자료(=데이터)를 쉽게 찾기 위해 존재하는 색인(=인덱스 테이블) 

> 데이터베이스에서 인덱스란 테이블에 대한 검색 성능(SELECT)을 향상시키기 위한 자료구조의 한가지입니다. 
<br/>
<br/>

### Index사용 이유
**원하는 데이터 조회시 불필요한 작업을 줄여 비용을 아끼기 위함** 
만약 1억건의 데이터가 있다고 치겠습니다. 이 1억건의 데이터 중 자주 사용되는 데이터들은 메모리에 올라가 조회 시 빠르게 찾아올 수 있습니다. 하지만 그렇지 않은 경우에 데이터베이스는 
이 1억건의 데이터를 모두 조회합니다. 이러한 조회 방식을 **FULL TABLE SCAN** 방식이라고 합니다. **FULL TABLE SCAN** 조회 방식을 개선하기 위해 인덱스라는 자료구조가 생겨났습니다.
실제 DB를 사용하면서 인덱스를 쓰는 이유를 살펴보자면 아래와 같습니다.
<br/>
> * WHERE 구문과 일치하는 열을 빨리 찾기 위해.
> * 특정 열을 고려 대상에서 빨리 없애 버리기 위해.
> * 조인 (join)을 실행할 때 다른 테이블에서 열을 추출하기 위해.
> * 특정하게 인덱스된 컬럼을 위한 MIN() 또는 MAX() 값을 찾기 위해.
> * 사용할 수 있는 키의 최 좌측 접두사(leftmost prefix)를 가지고 정렬 및 그룹화를 하기 위해.
> * 데이터 열을 참조하지 않는 상태로 값을 추출하기 위해서 쿼리를 최적화 하는 경우.

### 인덱스의 생성원리
B+Tree 알고리즘으로 색인화를 하고 인덱스 자료구조 형식을 가지게 됩니다. B+Tree(Balanced Tree)에 대해선 아래에 더 자세히 알아보도록합시다. 
지금은 'Binary Tree > B-tree(Balanced Tree) > B+ tree'의 순서로 확장되었으며 이로 인해 색인화 과정에서 데이터가 한쪽으로 치우치지 않고 균형있는 tree 구조로
생기도록 도와주는 알고리즘이라고 보면 좋습니다.

어떤 테이블의 하나의 컬럼을 인덱스로 지정합니다. 그렇게 되면 초기 테이블 생성시 만들어지는 MYD,MYI,FRM 3개의 파일중에서
MYI에 해당 컬럼을 색인화(인덱싱)하여 저장합니다(인덱스 테이블 생성). 그래서 SELECT문으로 조회할때 WHERE 조건문에 인덱스로 지정한 컬럼으로 조건을 주게되면 마스터 테이블을 조회하지 않고
MYI파일을 검색해 해당 ROW를 찾습니다.그렇지 않을 경우 위에서 이야기한 것과 같이 FULL SCAN을 진행하여 시간이 더 소요됩니다.

### Index의 종류
여러 종류의 Index가 있지만 주로 많이 언급되고 사용되는 Index는 Clustered Index와 Non Clustered Index 두가지 입니다.
둘의 차이는 뭘까요? 우선 cluster의 뜻을 보면 '무리'라는 뜻을 가지고 있습니다. 이렇게 생각하면 위의 두가지를 '무리지어진 인덱스'와 '무리지어지지 않은 인덱스' 정도로 해석할 수 있습니다.


* **Clustered Index** (= 사용자 지정이 아닌 MYSQL 자동지정 생성 인덱스, 정렬된)


Clustered Index는 데이터가 테이블에 물리적으로 저장 되는 순서를 정의(설정)한다. 즉, 클러스터 형 인덱스는 특정 컬럼을 기준으로 데이터들을 정렬시킨다.

1. 테이블에 AUTO INCREMENT로 생성된 PK 컬럼이 있다면 데이터베이스가 자동으로 해당 컬럼을 Clustered Index로 지정합니다.
2. pk가 없다면 Unique key를 Clustered Index로 지정합니다.
3. unique컬럼도 하나도 없다면? MySQL에서 내부적으로 Hidden Clustered Index Key (row ID)를 만들어 Clustered Index로 사용합니다.
4. 테이블 데이터는 오직 한 가지의 방법으로만 정렬되기 때문에 오직 테이블 당 하나의 클러스터 형 인덱스만 존재할 수 있다. 즉, 정렬 기준으로 오직 하나의 컬럼만을 선택할 수 있습니다.
5. Database에서 primary key의 제약조건(constraint)은 클러스터 된 인덱스를 자동으로 생성하기 때문에 우리가 일반적으로 테이블을 생성할 때 특정 컬럼에 primary key를 지정했다면, 자료가 자동으로 정렬되는 것입니다.
6. primary key를 설정하지 않은 테이블에 무작위로 데이터를 insert하고, 테이블을 조회하면 뒤죽박죽인 테이블을 보게될 것입니다.

그래서 Clustered는 왜 사용하는가?
삽입/삭제를해도 자동으로 데이터를 정렬해주기 때문이다(5번과 같음). 문제는 여기서 발생합니다. 우리가 한 배열의 중간에 값을 삽입하려고 하면 해당 위치 뒤쪽에 있는 공간들을 한칸씩 뒤로밉니다.
그리고 새로운 데이터를 삽입합니다. 삭제도 이와 마찬가지 입니다. 데이터가 적다면 문제가 안되지만 1억건이라고 했을때는 말이 달라집니다. 따라서 아래와 같은 경우에서 사용하는 것을 권장합니다.
* 테이블 데이터가 자주 업데이트 되지 않는 경우
* 항상 정렬 된 방식으로 데이터를 반환해야하는 경우
* 테이블은 정렬되어있기 때문에 ORDER BY 절을 활용해 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.읽기 작업이 월등히 많은 경우, 이때 매우 빠르다.

<img src="https://user-images.githubusercontent.com/78134917/153634902-e06d6359-61ae-46e0-beee-2da641207c51.png" width="700" height="500"/>



* **NonClustered Index** (= 사용자 지정생성 인덱스, 정렬되지 않은)
1. 테이블에 저장 된 물리적인 순서에 따라 데이터를 정렬하지 않는다. 즉, 순서대로 정렬되어 있지 않다.
2. 논 클러스터 형 인덱스는 테이블 데이터와 함께 테이블에 저장되는 것이 아니라 별도의 장소에 저장된다. 마치, 위 책에서 index 페이지를 따로 나눈것 처럼 말이다.
3. 하나의 테이블에 여러개의 논 클러스터 형 인덱스를 설정할 수 있다.

어떤 경우에 nonClustered Index 생성?
* where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자할 때
* 데이터가 자주 업데이트 될 때
* 특정 컬럼이 쿼리에서 자주사용 될 때

<img src="https://user-images.githubusercontent.com/78134917/153635772-657973eb-a5d9-495a-a8ea-f34a33f60b0a.png" width="700" height="500"/>


**두가지 인덱스의 차이 정리**
* Clustered 인덱스는 테이블당 오직 한개만 존재한다. 반면에 Non-Clustered 형은 테이블 당 여러개의 인덱스를 생성할 수 있다.
* Clustered 인덱스는 오직 테이블을 정렬한다. 그러므로 별도의 공간을 필요로하지 않는다. Non-Clustered 인덱스는 저장되는 별도의 공간(약 10%)이 필요하다.
* Clustered 인덱스는 통상적으로 데이터를 찾는데 추가적인 스텝을 거치지 않기 때문에 Non-Clustered 인덱스보다 속도가 빠르다.
* Clustered 인덱스는 데이터를 삽입할 때, 모든 테이블에 존재하는 데이터들의 순서를 유지해야하므로 많은 비용이 발생한다. Non-Clustered는 별도의 공간에 인덱스를 생성해야하기 때문에 추가작업이 필요하다.
<br/>
<br/>

## 정규화
<br/>
### 참조한 페이지
https://gwang920.github.io/database/clusterednonclustered/
# Operating System
