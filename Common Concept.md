# #1. Client vs Server vs Host

공부의 이유 : 둘의 개념이 모호하게 잡혀있어서 단어의 정의를 내리기 위해 공부한다.

---
![image](https://user-images.githubusercontent.com/78134917/164178377-03ad8c47-2637-45a2-9943-8164255b00ac.png)


우선 둘다 컴퓨터다.(서버용 컴퓨터가 특수하게 생겨났을 뿐이다.)

Server : 컴퓨터 장치 또는 컴퓨터 프로그램을 일컷는다. 

**Client**

대표적으로 웹 브라우저가 설치된 서버를 클라이언트라 볼 수 있다. 즉, 사용자(=요청자) 쪽에 있는 컴퓨터 또는 프로그램을 클라이언트

**Server**

요청 처리의 기능을 담당하는 컴퓨터를 서버라고 부른다. 하지만 서버라는 역할을 담당하려면 24시간 클라이언트(요청자)의 요청을 기다리고 있어야한다. 

결론 Client, Server 둘다 컴퓨터지만 데이터 요청자와 데이터 제공자의 개념으로 나눠져있는 것이다.

**Host**

네트워크에 연결된 하나의 디바이스이다. **호스트는** IP를 가지고 있고 양방향 통신이 가능한 컴퓨터를 의미한다.  
  
  
  
# #2. 가상화

**가상화란?**  


 하나의 물리적인 하드웨어 서버를 여러개의 어플리케이션 서버로 나누는 것이다. 여러개의 Os가 물리적인 하드웨어를 사용함으로써 사용 효율을 끌어 올릴 수 있다.

가상화에는 대표적으로 두가지 플랫폼 가상화 와 리소스 가상화가 존재한다. 이것들을 통해 클라우드 서비스의 iaas, paas등이 존재한다. 

**플랫폼 가상황(소프트웨어적 가상화 기술)**  

개념 :

맥의 페럴러즈와 같이 주 운영체제 위에 보조 운영체제(리눅스, 윈도우 등)을 올리는 것을 말한다.

맥북에서 윈도우 운영체제를 창으로 띄워 사용하는 것을 의미.

사용이유 :

프로그램의 호환성과 편리함 때문에 사용한다. 

한계 : 

과거에는 보조 운영체제는 하드웨어(메모리, cpu, gpu 등)에 직접 접근하지 못해 성능적 한계를 가졌었지만 현재는 보조운영체제는 cpu까지 직접 접근이 가능하다.

**리소스 가상화(하드웨어적 가상화 기술)**  


개념 : 

수많은 하드웨어를 하나의 컴퓨팅자원으로 생각하고 해당 자원을 나눠서 사용하는 것. 


## #3. gradle compile과 implementation 차이
개발을 하던 중 한가지 궁금증이 생겼다. gradle의 dependency 설정시 compile과 implementation의 차이가 뭘까  
compile의 경우 사용자가 원하는 모듈만 가져오는 것이 아니라 관련된 라이브러리도 모두 가져온다. 반면 Implementation의 경우 원하는 모듈만 가져올 수 있다. 


## #4. @Override

Ovrride의 annotation의 경우 명시적인 목적으로 사용한다. 
모든 annotation이 명시적 목적으로 사용되는 건 아니다. annotation에 맞는 기능도 추가하는 것이 가능하다. 

@Override의 경우 ‘이거 내가 부모꺼 덮어썼어 이거 가져다 쓰면 돼!’와 이거 내가(자바) 문법 체크 해줄게!! 가 된다.
